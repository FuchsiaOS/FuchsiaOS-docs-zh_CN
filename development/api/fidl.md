FIDL API 可读性注释：

[TOC]

# **整体建议：**

   这一部分包含了在 [Fuchsia](https://fuchsia.googlesource.com/docs/+/master/development/languages/fidl/README.md)接口定义语言中关于定义接口的一些整体建议。

## **协议不是对象**

  FIDL是一种为了定义内部进程通信的协议的语言；虽然这些语法类似于面向对象接口的定义，但是设计者考虑更多的是同种的网络协议而不是实体系统。例如：

设计一个高质量的接口，你需要考虑带宽，延迟以及流程控制。你也需要考虑的是接口不只是一组可操作的逻辑分组：接口还对请求加强了FIFO排序，并将接口分为两个较小的接口意味着两个不同接口上发出的请求可以相对于彼此重新排序。

## **专注于类型** 

  设计FIDL的良好起点是设计你将在协议中所使用的数据结构，例如，关于网络的FIDL协议可能包含各种IP地址类型的数据结构，以及图形的FIDL协议可能包含各种几何概念的数据结构。 您应该能够查看这些类型名称，并对协议操作的概念以及如何构造用于操纵这些概念的接口有一些直观的感受.

## **语言中立性质**

   FIDL后端支持许多不同的语言。 您应该避免针对任何特定目标语言过度专业化FIDL定义。 随着时间的流逝，您的FIDL协议可能会被许多种不同的语言所使用，甚至可能是一些如今没有被支持的语言。 FIDL是将系统结合在一起并让Fuchsia支持多种语言和运行时的粘合剂。 如果您过度定制化自己喜欢的语言，则会破坏FIDL设计的核心意义。

## **命名：**

```
The Naming of Cats is a difficult matter,
It isn't just one of your holiday games;
    --- T.S. Eliot
```

在FIDL中定义的名称用于生成每一种目标语言的标识符，一些语言将语义或者常规含义附加到各种形式的名称上。例如在GO语言中标识符中的首字母是否大写将控制标识符的可见性。 因此，许多语言后端都会转换库中的名称，以使其更适合其目标语言。本节中的命名规则是FIDL源代码的可读性，每种目标语言的可用性以及目标语言之间的一致性之间的一种平衡行为。

避免使用通用词，例如`goto`。语言后端会将保留的单词转换为非保留的标识符，但是这些转换会降低这些语言的可用性。 避免使用常用的保留关键字会降低应用这些转换的频率。

虽然某些FIDL关键字也是目标语言常用的保留字（例如C和C ++中的`struct`），因此应避免使用，其他FIDL关键字尤其是请求和句柄通常是描述性的，可以适当地使用。

名称的头部和尾部不能包含下划线。头部或尾部下划线在某些语言中具有特定的语义含义（例如，`Dart`中的前导下划线控制可见性），而在其他语言中则具有常规含义（例如，尾部下划线通常用于C ++中的成员变量）。 此外，FIDL编译器使用前导和尾随下划线来修饰标识符以避免冲突。

# **库函数**

库名称是句点分隔的标识符列表。 库名称中除最后一个以外的其他部分也称为名称空间。 名称的每个组成部分均小写，并且必须与以下正则表达式匹配：[a-z] [a-z0-9] *。

我们使用这些限制性规则是因为不同的目标语言对它们如何限定名称空间，库或程序包具有不同的限制。 我们选择了一个保守的最小公分母，以使FIDL与我们当前的目标语言以及潜在的未来目标语言配合良好。

相对于产品或代号（例如，fuchsia.amber或fuchsia.mozart），功能名称（例如fuchsia.media）优先。 当产品在Fuchsia之外具有某种外部存在并且接口特定于该产品时，则使用产品名称是合适的。 例如，fuchsia.cobalt是Cobalt接口的一个比fuchsia.metrics更好的名称，因为其他具体实现（例如Firebase）不太可能实现相同的协议。

FIDL 库函数是定义在Fuchsia的源码树目录下(i.e,定义在[fuchsia.googlesource.com](http://fuchsia.googlesource.com))必须是在fuchsia的顶层的命名空间中(e.g., fuchsia.ui)除非（a）库定义了FIDL语言本身或其部分 一致性测试套件，在这种情况下，顶级名称空间必须为fidl，或者（b）该库仅用于内部测试，并且不包含在SDK或生产版本中，在这种情况下，顶级名称空间必须为 测试。

避免使用超过两个点的库名称（例如fuchsia.foo.bar.baz）。 在某些情况下，第三个点是合适的，但这种情况很少见。 如果使用两个以上的点，则应该有一个选择的特定原因。

最好从名称更多的库引入名称更具体的库，而不是相反的库。 例如，fuchsia.foo.bar可能依赖于fuchsia.foo，但是fuchsia.foo不应依赖于fuchsia.foo.bar。 这种模式对于可扩展性更好，因为随着时间的推移，我们可以添加更多具有更特定名称的库，但是只有有限数量的具有较不特定名称的库。 让具有较少特定名称的库知道具有较高特定名称的库将赋予当前相对于将来的现状特权。

库名称不得包含以下组件：通用，服务，实用程序，基础，f <字母> l，zx <单词>。 避免使用这些（和其他）无意义的名称。 如果fuchsia.foo.bar和fuchsia.foo.baz共享许多希望分解到单独库中的概念，请考虑在fuchsia.foo中而不是在[fuchsia.foo.common](http://fuchsia.foo.common)中定义这些概念。

# **顶层设计**

避免和库名称中重复名称。 例如，在fuchsia.process库中，启动进程的接口应命名为Launcher而不是ProcessLauncher，因为该库中已经出现了process这样的名称。 在所有目标语言中，顶级名称以某种方式由库名称确定范围。

# **原始别名**

原始别名必须是lower_snake_case

using vaddr = uint64;

原始别名不得与库中的名称重复。 在所有目标语言中，原始别名被基础原始类型替换，因此不会引起命名冲突。

# **常量Constants**

常量必须在ALL_CAPS_SNAKE_CASE中命名。

const uint64 FOO_BAR = 4096;

常量名称不得重复包含库中的名称。 在所有目标语言中，常量名称受其封闭库的限制。

# **接口**

接口必须在UpperCamelCase中命名，并且必须是名词短语。 通常，接口使用建议动作性名词来命名。例如，AudioRenderer是一个名词，表明接口与渲染音频有关。同样，启动器是一个名词，表明接口与启动某些内容有关。接口也可以是被动名词，尤其是当它们与实现所拥有的某些状态有关时。例如，目录是一个名词，表明该接口用于与实现所拥有的目录进行交互。

可以使用面向对象的设计模式来命名接口例如，fuchsia.fonts.Provider使用“ provider”后缀，它表示接口提供字体接口（而不是表示字体本身）。同样，fuchsia.tracing.Controller使用“ controller”后缀，它表示接口控制跟踪系统（而不是表示跟踪本身）。

名字管理器可能被用作为接口扩大范围的最后保障；例如，fuchsia.power.Manager。 但是，请注意，“Manager”接口更倾向于大多数功能的松耦合；在多接口中更好的因子。

接口不得包含名称“ service”。所有接口都定义服务。 这个术语是没有意义的。例如，[fuchsia.net.oldhttp.HttpService](http://fuchsia.net.oldhttp.HttpService)以两种方式违反了该规则。 首先“ http”前缀与库名冗余。 其次，禁止使用“service”后缀。 注意，继承FIDL库[fuchsia.net.http](http://fuchsia.net.http)只是忽略了这个无用的接口。

# **方法：**

方法必须在UpperCamelCase中命名，并且必须是动词短语。 例如，GetBatteryStatus和CreateSession是动词短语，指示该方法执行什么操作和方法的意义。

事件发生时调用的“侦听器”或“观察者”接口上的方法应以On为前缀，并且描述过去发生的事件。 例如，ViewContainerListener接口具有一个命名为OnChildAttached的方法。 类似，事件（即，从服务器到客户端的未经请求的消息）应以On为前缀，并描述过去时发生的事件。 例如，AudioCapturer接口具有一个名为OnPacketCaptured的事件。

# **参数：**

参数必须类似如下命名：lower_snake_case

# **结构体和联合体：**

结构和联合必须是以驼峰命名如：UpperCamelCase，并且必须是名词短语。 例如，Point是定义空间中位置的结构体，而KeyboardEvent是定义与键盘相关的事件的结构中。

# **结构和联合体成员：**

结构和联合成员必须以小写下划线形式命名，如：lower_snake_case。 如果可行，请优先使用单个单词的名称，因为单个单词的名称在目标语言之间的呈现更加一致。 但是，如果单个单词会造成歧义或令人困惑，请不要担心使用多个单词。

成员名称不能与自封闭类型（或库）的名称重复。 例如，包含事件传递时间的KeyboardEvent成员应命名为time而不是event_time，因为name事件已经出现在封闭类型的名称中。 在所有目标语言中，成员名称均受其封闭类型的限制。

**枚举**

枚举必须是以驼峰命名形式：UpperCamelCase，并且必须是名词短语。 例如，PixelFormat是一个枚举，它定义如何将颜色编码为图像中的比特位。

**枚举成员**

枚举成员必须是全大写下划线分开形式命名：ALL_CAPS_SNAKE_CASE。

枚举成员名称不能和包含类型（或库）的名称重复。 例如，PixelFormat枚举的成员应命名为ARGB而不是PIXEL_FORMAT_ARGB，因为名称PIXEL_FORMAT已出现在封闭类型的名称中。 在所有目标语言中，枚举成员名称均受其封闭类型的限制。

**组织：**

句法：

使用4个空格缩进。

切勿使用tab。

避免尾随空格。

结构，联合，枚举和接口结构的声明与其他声明用一个换行符分开。

用一个换行符结束文件。

注释：

使用 // 注释来记录您的库。将注释放在要描述的内容上方。使用合理完整的句子，并使用适当的大写字母和句号：

struct Widget {

  // Widgets must be published with monotonically increasing ids.

  uint64 id;

  // Relative to the center.

  Point location;

};

由某些外部的真实源文件定义的类型或值，应通过引用外存在的文件进行注释。例如，参考一份WIFI描述配置结构的具体说明书。同样，如果结构必须匹配C头文件中定义的ABI，请引用C的头文件。

如果你希望你的注释“流程”目标语言，请使用///作为注释介绍器（是的，连续三个正斜杠）或[Doc =“ this is a comment”]属性：

/// this is a comment that flows through to the target

[Doc = "and so is this”]

**流程与常规注释指南：**

对于流经注释，///形式优于[Doc =]形式； 后者旨在用作内部实现挂钩。

在决定应该使用常规“ //”注释还是通过流程性注释时，请牢记以下几点。

定期评论：

内部使用“待办事项”评论

版权声明

实施细节

流程性注释：

参数命，函数的描述

使用说明

例如：

// TODO -- this function needs additional error checks

/// WatchedEvent describes events returned from a DirectoryWatcher.

struct WatchedEvent {

…

文件：

库由一个或多个文件组成。 这些文件按照以下约定存储在相应的目录层次结构中：

fidl/<library>/[<dir>/]*<file>.fidl

<library>目录使用FIDL库的点分隔名称命名。 <dir>子目录是可选的，通常地是不用于文件少于十二个的库。 此目录结构与Fuchsia SDK中包含FIDL文件的方式匹配。

将库分为文件对库的使用者没有特别的影响。 声明（包括接口）可以在整个库中互相引用，也可以通过库互相引用，而不论它们出现在哪个文件中。 将库划分为文件以最大程度地提高可读性。

对于库中的文件，最好使用DAG依赖关系图。

最好保持相互引用的定义在文本上彼此依赖，最好在同一文件中。

对于复杂的库，最好在子文件中定义纯数据类型或常量，并且定义同时引用这些类型的接口。

**序数：**

接口包含许多方法。在其声明中，为每个方法分配了唯一的32位标识符，称为序数。

接口在两个方向上进化。首先，接口可以使用新的序数增长新的方法。其次，超级接口可以由子接口扩展。子接口具有其父接口的所有方法以及自己的方法。

本指南的目的是避免这些扩展机制发生冲突。

切勿使用零序数,（编译器禁止零序。）

接口内的常规对象应按连续的块分配。例如：

0x80000001--0x80000007

1,2,3

1000--1010、1100--1112、1200--1999

接口中的新序数应使用块中的下一个序数。在1、2和3之后，使用4。

相关接口应考虑使用附近和不同的序数块：

接口A、B在同一个库中；可能分别选择在块0x100-0x1ff和0x200-0x2ff中去分配。

期望由子接口扩展的接口应在注释中显式声明序数块。

# **库的结构**

仔细考虑如何将类型和接口定义划分为库。将这些定义分解为库的方式对这些定义的使用者有很大影响，因为FIDL库是你的协议的依赖性和分布单位。

FIDL编译器要求库之间的依赖关系图是DAG，这意味着您不能跨库边界创建循环依赖关系。但是，您可以在一个库中创建（某些）循环依赖项。

要决定是否将一个库分解为较小的库，请考虑以下问题：

库的客户是否分解为想要使用库中功能或声明子集的单独角色？如果是这样，请考虑将库分成针对每个角色的单独的库。

该库是否符合具有普遍被理解的结构的行业概念？如果是这样，请考虑构建您的库以使其符合行业标准结构。例如，蓝牙被组织为fuchsia.bluetooth.le和fuchsia.bluetooth.gatt以匹配行业中对这些概念的一般理解。同样，[fuchsia.net.http](http://fuchsia.net.http)对应于行业标准的HTTP网络协议。

其他许多库是否依赖该库？如果是这样，请检查这些传入依赖项是否真的需要依赖整个库，或者是否存在可以从库中分解出来以接收大量传入依赖项的“核心”定义集。

理想情况下，我们将为fuchsia整体创建FIDL库结构，这是全球最佳的选着。但是，康威（Conway）的法则规定“设计系统受到约束的组织只能制作出这些组织的通信结构的复制品。”我们应该花一些时间与Conway定律作对抗。

**类型**

如“一般建议”中所述，您应特别注意协议定义中使用的类型。

**保持一致**

对同一概念使用一致的类型。 例如，在整个库中始终对特定概念使用uint32或int32。 如果为概念创建结构体，请始终使用该结构体表示该概念。

理想情况下，类型也应跨库边界一致使用。 检查相关的库以了解类似的概念，并与这些库保持一致。 如果库之间共享许多概念，请考虑将这些概念的类型定义分解为一个公共库。 例如，fuchsia.mem和fuchsia.math分别包含许多相同的表示内存和数学概念的类型。

**首选语义类型**

创建结构以命名常用概念，即使可以使用原函数表示这些概念。 例如，IPv4地址是网络库中的一个重要概念，即使可以使用原语表示数据，也应使用结构来命名它：

struct Ipv4Address {

  array<uint8>:4 octets;

};

在对性能至关重要的目标语言中，结构以行表示，这降低了使用结构命名重要概念的成本。

**考虑使用fuchsia.mem.Buffer**

虚拟内存对象（VMO）是一个内核对象，代表虚拟内存的连续区域。 VMO以每页为单位跟踪内存，这意味着VMO本身不会以字节粒度跟踪其大小。当以FIDL消息发送内存时，通常将需要同时发送VMO和大小。而不是单独发送这些原语，不如考虑使用fuchsia.mem.Buffer，它结合了这些原语并命名了此通用概念。

指定向量和字符串的界限

大多数向量和字符串声明应指定长度限制。每当您忽略长度限制时，请考虑消息的接收者是否真的想处理任意长序列，或者极端长序列是否表示滥用。

请记住，在通过zx :: channel发送时，缺少上限的声明会隐含地受最大消息长度的限制。如果确实存在任意长序列的用例，则仅忽略一个边界可能无法解决这些用例，因为尝试提供极长序列的客户端可能会达到最大消息长度。

要处理具有任意大序列的用例，请考虑使用以下讨论的分页模式之一将序列分解为多条消息，或考虑将数据从消息本身移出，例如移至fuchsia.mem.Buffer中。

**错误**

为您的用例选择适当的错误类型，并在报告错误方面保持一致。

将状态类型用于与内核对象或IO相关的错误。 例如，fuchsia.process使用状态，因为该库在很大程度上与操纵内核对象有关。 另举一个例子，因为库与IO有关，fuchsia.io广泛使用状态。

对其他域使用特定于域的枚举错误类型。 例如，当您希望客户端收到错误然后停止而不是将错误传播到另一个系统时，请使用一个枚举。

如果方法可以返回错误或结果，请使用以下模式：

enum MyStatus { OK; FOO; BAR; ... };

interface Frobinator {

  1: Frobinate(...) -> (MyStatus status, FrobinateResult? result);

};

在某些不常见的情况下，如果可能的错误条件的范围很大并且描述性错误消息可能对客户端有用，则接口除了状态或枚举值之外还可能包含错误的字符串描述。 但是，包含字符串会带来困难。 例如，客户端可能尝试解析字符串以了解发生了什么，这意味着字符串的确切格式成为接口的一部分，当字符串本地化时，这尤其成问题。 安全说明：同样，向客户端报告堆栈跟踪或异常消息可能会无意间泄漏特权信息。

**我应该定义一个结构来封装方法参数（或响应）吗？**

无论何时定义方法，都需要决定是单独传递参数还是将参数封装在结构体中。做出最佳选择涉及平衡多个因素。考虑以下问题，以帮助您做出决策：

有有意义的封装边界吗？如果一组参数可以作为一个单元传递，因为它们具有超出此方法的内聚性，你可能希望将这些参数封装在结构体中。 （希望你在开始设计协议时就已经确定了这些紧密联系的组，因为你遵循了上面的“一般建议”，并尽早关注了类型。）

该结构体对除调用方法之外的任何其他东西是否有用吗？如果没有，请考虑分别传递参数。

你是否在许多方法中重复相同的参数组？如果是这样，请考虑将这些参数分组为一个或多个结构。你可能还会考虑重复参数是否表明这些参数是内聚的，因为它们代表了协议中的一些重要概念。

是否有大量可选参数，否则通常会给其默认值？如果是这样，请考虑使用结构体减少调用者的样板。

是否存在同时总是为null或非null的参数组？如果是这样，请考虑将这些参数分组为可为空的结构，以在协议本身中强制执行该不变式。例如，上面定义的FrobinateResult结构包含的值在error不是MyError.OK的同时始终为null。

**我应该使用****string还是\**vector?\****

在FIDL中，string 据必须是有效的UTF-8，这意味着字符串可以表示Unicode代码点的序列，但不能表示任意二进制数据。 相反，vector或array可以表示任意二进制数据，并不表示Unicode。

使用string作为文本数据：

使用string来表示软件包名称，因为软件包名称必须是有效的UTF-8字符串（带有某些排除的字符）。

使用string表示包中的文件名，因为包中的文件名必须是有效的UTF-8字符串（带有某些排除的字符）。

使用string来表示媒体编解码器名称，因为媒体编解码器名称是从有效的UTF-8字符串的固定词汇表中选择的。

使用string表示HTTP方法，因为HTTP方法由固定选择的字符组成，这些字符始终是有效的UTF-8。

对非文本数据使用vector或array：

将vector <uint8>用于HTTP标头字段，因为HTTP标头字段未指定编码，因此不一定以UTF-8表示。

对于MAC地址，请使用array <uint8>：6，因为MAC地址是二进制数据。

对UUID使用array <uint8>：16，因为UUID是（几乎！）任意二进制数据。

**我应该使用\**vector\******还是array****?**

vector是可变长度序列，以离散数据格式写入。 array是固定长度的序列，写入是以线性表示。

将vector用于可变长度数据：

对日志消息中的标签使用vector，因为日志消息可以具有零到五个标签。

将array用于定长数据：

对MAC地址使用array，因为MAC地址始终为6个字节长。

**什么时候应该使用枚举？**

（注意：本节取决于FINUM 2.1的推荐功能，该功能使枚举具有可扩展。）

如果枚举值集受Fuchsia项目限制和控制，请使用枚举。例如，Fuchsia项目定义了指针事件输入模型，通过PointerEventPhase枚举的值控制。

在某些场景下，即使我们可以合理地期望希望注册新值的人将向Fuchsia源树提交补丁来注册其值，即使Fuchsia项目本身不控制枚举值集，也应使用一个枚举 。例如，Fuchsia图形驱动程序需要理解纹理格式，这意味着即使那些结构格式集由图形硬件供应商控制，开发人员也可以在这些驱动程序上添加新的结构格式。作为反例，不要使用枚举来表示HTTP方法，因为我们不能合理地期望使用新颖HTTP方法的人向Fuchsia源树提交补丁。

对于先验无界集合，如果您预想要动态扩展集合，则string可能是更合适的选择。例如，使用string来表示媒体编解码器名称，因为中介程序可能能够使用新颖的媒体代码名称来做一些合理的事情。

如果一组枚举值由外部实体控制，请使用整数（适当大小）或string。例如，使用整数（或某种大小）来表示USB HID标识符，因为USB HID标识符集由行业协会控制。同样，使用string表示MIME类型，因为MIME类型（至少在理论上）由IANA注册中心控制。

**好的设计模式**

本节描述了许多FIDL协议中重复出现的几种良好的设计模式。

Interface request pipelining(流水线)设计模式

最佳和最广泛使用的设计模式之一是接口pipelining(流水线)设计模式。 客户端不返回实现接口的通道，而是发送通道并请求服务器将接口的实现绑定到该通道：

GOOD:

interface Foo {

  1: GetBar(string name, request<Bar> bar);

};

BAD:

interface Foo {

  1: GetBar(string name) -> (Bar bar);

};

此模式很高效，因为客户端在开始使用Bar接口之前不需要等待返回信息。 而是，客户端可以立即处理Bar的队列消息。 一旦Bar的实现绑定到接口请求技术，这些消息将由内核缓冲并最终进行处理。 相反，如果服务器返回Bar接口的实例，则客户端需要等待整个返回过程，然后再为Bar处理队列消息。

如果请求可能失败，请考虑通过描述操作是否成功的回复扩展此模式：

interface CodecProvider {

  1: TryToCreateCodec(CodecParams params, request<Codec> codec) -> (bool succeed);

};

为了处理失败情况，客户端等待答复，如果请求失败，则采取其他措施。 另一种方法是使接口具有服务器在协议开始时发送的事件：

interface Codec2 {

  1: -> OnReady();

};

interface CodecProvider2 {

  1: TryToCreateCodec(CodecParams params, request<Codec2> codec);

};

为了处理失败的情况，客户端等待OnReady事件，并在事件到达之前关闭Codec2通道时采取其他措施

但是，如果请求很可能会成功，则使用任何一种成功信号都可能是不好的，因为该信号使客户端可以区分通常应以相同方式处理的不同失败模式。 例如，客户端应以与最初无法访问的服务相同的方式来处理建立连接后立即失败的服务。 在这两种情况下，该服务都不可用，客户端应生成错误或寻找另一种方法来完成其任务。

**流量控制**

FIDL消息由内核缓冲。 如果一个端点产生的消息多于另一端点消耗的消息，则这些消息将在内核中累积，从而占用内存，并使系统更难以恢复。 取而代之的是，经过精心设计的协议应限制消息的生成，以匹配消耗这些消息的速率，这种属性称为流控制。

内核以通道背压的形式提供了一些流量控制。 但是，大多数协议都应具有协议级别的流量控制，并在协议无法按设计工作时使用通道背压作为逆止器，以保护系统的其余部分。

流量控制是一个广泛而复杂的主题，并且有许多有效的设计模式。 本节讨论一些较流行的流量控制模式，但并不详尽。 协议可以自由使用最适合其用例的任何流量控制机制，即使该机制未在下面列出。

**Prefer pull to push**

如果不进行仔细的设计，服务器将数据推送到客户端的协议通常会具有较差的流控制。提供更好的流控制的一种方法是让客户端从服务器拉取一个或一个范围的数据。**pull**拉取模型具有内置的流控制功能，客户端自然会限制服务器生成数据的速率，并避免被服务器推送的消息淹没。

实现基于请求的协议的一种简单方法是使用悬挂获取模式在服务器上“驻留回调”。在这种模式下，客户端发送GetFoo消息，但是服务器不会立即回复。而是，服务器在“ foo”可用时进行答复。客户端使用foo并立即发送另一个挂起的get。客户端和服务器每个数据项都执行一个工作单元，这意味着它们都不能领先于另一个。

当要传输的数据项集有大小限制并且服务器端状态很简单时，悬挂获取模式会很好地工作，但是在客户端和服务器需要同步其工作的情况下，该方法在这样的场景下不能高效工作。

**Throttle push using acknowledgments(确认形式的push模式)**

在使用push推送的协议中提供流控制的一种方法是确认模式，在该模式中，调用者提供了调用者用于流控制的确认响应。 例如，考虑以下通用侦听器接口：

interface Listener {

  1: OnBar(...) -> ();

};

侦听器期望在收到OnBar消息后立即发送空响应消息。 该响应不会将任何数据传递给调用方。 而是，响应使调用者可以观察被调用者使用消息的速率。 调用者应限制其产生消息的速率，以匹配被调用者消耗消息的速率。 例如，调用者可能只安排一条消息（或固定数量的消息）进行传输（即等待确认)。

**事件**

在FIDL中，服务器可以向客户端发送未经请求的消息，称为事件。 使用事件的协议需要特别注意流量控制，因为事件机制本身不提供任何流量控制。

事件的一个比较好的用例是在整个通道的生命周期内最多发送一个事件实例。 在这种模式下，协议不需要对该事件进行任何流控制：

interface DeathWish {

  1: -> OnFatalError(status error_code);

};

事件的另一个好用例是客户端请求服务器产生事件，并且服务器产生的事件总数受到限制。 此模式是悬挂获取模式的复杂版本，在该模式中，服务器可以响应“get”请求的次数是有限的（而不是一次）：

interface NetworkScanner {

  1: ScanForNetworks();

  2: -> OnNetworkDiscovered(string network);

  3: -> OnScanFinished();

};

如果事件数量没有先验约束，考虑让客户端通过发送消息来确认事件。 此模式是确认模式的更别扭的版本，在该模式中，客户端和服务器的角色已切换。 就像在确认模式中一样，服务器应限制事件的产生以匹配客户端使用事件的速率：

interface View {

  1: -> OnInputEvent(InputEvent event);

  2: NotifyInputEventHandled();

};

与正常确认模式相比，此模式的一个优势是客户端可以通过一条消息更轻松地确认多个事件，因为确认与正在确认的事件无关。 此模式通过减少确认消息的数量来实现更有效的批处理，并且对于多事件类型的有序处理非常有效：

interface View {

  1: -> OnInputEvent(InputEvent event, uint64 seq);

  2: -> OnFocusChangedEvent(FocusChangedEvent event, uint64 seq);

  3: NotifyEventsHandled(uint64 last_seq);

};

### 

### **Feed-forward dataflow(前向反馈数据流)**

一些协议具有前向反馈数据流，它通过使数据流主要在一个方向上（通常从客户端到服务器）来避免往返延迟。 该协议仅在必要时同步两个端点。 前向反馈数据流还提高了吞吐量，因为执行给定任务所需的总上下文切换较少。

前向反馈数据流的关键是无需客户端在发送后续消息之前先等待先前方法调用的结果。 例如，接口请求流水线消除了客户机在客户机可以使用接口之前等待客户机用接口答复的需求。 同样，客户端分配的标识符（参见下文）使客户端无需等待服务器为服务器保留的状态分配标识符。

通常，前向反馈协议将涉及客户端提交一系列单向方法调用，而无需等待服务器的响应。 提交这些消息后，客户端通过调用诸如Commit或Flush之类的具有响应的方法来显式与服务器同步。 响应的消息可能为空，也可能包含有关所提交序列是否成功的信息。 在更复杂的协议中，单向消息表示为命令对象的并集，而不是单个方法调用，参见下面的命令并集模式。

使用前向反馈数据流的协议可以与积极的错误处理策略配合使用。 与其让服务器用状态值答复每个方法，不如鼓励客户端等待每条消息之间的往返，代替倘若由于一个没有在客户端可控制范围下而失败的原因；才包含一个状态回应。 如果客户端发送一条消息，表明客户端应该知道该消息无效（e.g，引用了无效的客户端分配标识符），通过关闭连接来发出错误信号。 如果客户端发送一条消息，该客户端可能不知道该消息无效，请提供一个响应，指示成功或失败（这需要客户端进行同步），或者记住错误并忽略后续的相关请求，直到客户端进行同步并从错误中以某种方式恢复 。

Example:

interface Canvas {

  1: Flush() -> (status code);

  2: Clear();

  3: UploadImage(uint32 image_id, Image image);

  4: PaintImage(uint32 image_id, float x, float y);

  5: DiscardImage(uint32 image_id);

  6: PaintSmileyFace(float x, float y);

  7: PaintMoustache(float x, float y);

};

### **客户端分配的标识符**

通常，接口将使客户端具有可以操纵服务器所拥有的多个状态。 在设计对象系统时，解决此问题的典型方法是为服务器保存的每个相关状态创建单独的对象。 但是，在设计协议时，为每个状态使用单独的对象有几个缺点：

为每个逻辑对象创建单独的接口实例会消耗内核资源，因为每个接口实例都需要一个单独的channel对象。 每个接口实例都维护一个单独的消息FIFO队列。 对每个逻辑对象使用单独的接口实例意味着发送到不同对象的消息可以相对于彼此重新排序，从而使客户端和服务器之间的无序交互。

客户端分配的标识符模式通过让客户端将uint32或uint64标识符分配给服务器保留的对象来避免这些问题。 在客户端和服务器之间交换的所有消息都通过单个接口实例进行传递，该接口实例为整个交互提供了一致的FIFO顺序。

让客户端（而不是服务器）分配标识符可以实现前反馈数据流，因为客户端可以将标识符分配给对象，然后立即对该对象进行操作，而无需等待服务器用对象的标识符进行回复。 在这种模式下，标识符仅在当前连接的范围内有效，并且通常将零标识符保留为哨兵。 安全说明：客户端不应将其地址空间中的地址用作其标识符，因为这些地址可能会泄漏其地址空间的布局。

客户端分配的标识符模式有一些缺点。 例如，对于开发人员客户端更难编写，因为客户端需要管理自己的标识符。 开发人员通常希望创建一个客户端库，为服务端提供面向对象的前端，以隐藏管理标识符的复杂性，而标识符本身就是一种反模式（请参见下面的客户端库）。

当您想使用内核的对象功能系统来保护对该对象的访问时，强烈建议您应该创建一个单独的接口实例来表示一个对象而不是使用客户端分配的标识符。 例如，如果您希望客户端能够与对象进行交互，但又不希望客户端与其他对象进行交互，则创建单独的接口实例意味着您可以将基础通道用作控制访问这个对象的能力

**命令联合模式**

在使用前向反馈数据流的协议中，客户端通常在发送双向同步消息之前向服务器发送许多单向消息。 如果协议涉及大量消息，则发送消息的负载开销会变得很明显。 在这种情况下，请考虑使用命令联合模式将多个命令批处理为一条消息。

在这种模式下，客户端发送命令 vector，而不是为每个命令发送单独的消息。 vector包含所有可能命令的并集，并且服务器除了使用方法序号之外，还使用并集标记作为命令分配的选择器：

struct PokeCmd { int32 x; int32 y; };

struct ProdCmd { string:64 message; };

union MyCommand {

  PokeCmd poke;

  ProdCmd prod;

};

interface HighVolumeSink {

 1: Enqueue(vector<MyCommand> commands);

 2: Commit() -> (MyStatus result);

};

通常，客户端在其地址空间中本地缓存命令，然后将它们批量发送到服务器。 客户端应在达到字节和句柄中的通道容量限制之前将批处理刷新到服务器。

对于消息量更大的协议，请考虑在数据平面的zx::vmo 中使用环形缓冲区，在控制平面使用相关的 zx::fifo 。 这样的协议给客户端和服务器带来了更高的实现负担，但是在需要最大性能时才能够合适使用。 例如，块设备协议使用这这种方法来优化性能。

**分页**

FIDL消息通常通过具有最大消息大小的通道发送。 在许多情况下，最大消息大小足以传输合理数量的数据，但是在某些情况下，则用于传输大量（甚至是无边界）数据。 传输大量或无边界信息的一种方法是使用分页模式。

#### **分页write操作**

#### 对服务器写分页的一种简单方法是让客户端以多条消息发送数据，然后使用“ finalize”方法使服务器处理发送的数据：

interface Foo {

  1: AddBars(vector<Bar> bars);

  2: UseTheBars() -> (...);

};

例如，fuchsia.process.Launcher使用此模式让客户端发送任意数量的环境变量。

此模式的更复杂的版本创建代表事务的接口，通常称为分离接口：

interface BarTransaction {

  1: Add(vector<Bar> bars);

  2: Commit() -> (...);

};

interface Foo {

  1: StartBarTransaction(request<BarTransaction> transaction);

};

当客户端可能并发执行许多操作并且将写入拆分为单独的消息而失去原子性时，此方法很有用。 注意BarTransaction 不需要Abort方法。 终止事务的更好的方法是让客户端关闭BarTransaction 接口。

**分页Read操作**

分页来自服务器的读取的一种简单方法是让服务器使发送多个响应使用事件做单独的请求：

interface EventBasedGetter {

  1: GetBars();

  2: -> OnBars(vector<Bar> bars);

  3: -> OnBarsDone();

};

依赖特定领域语义，此模式可能还需要第二个事件，该事件会在服务器完成数据发送时发出信号。 这种方法在简单情况下效果很好，但存在许多扩展问题。 例如，该协议缺少流控制，并且如果客户端不再需要其他数据（缺少关闭整个接口），则客户端将无法停止服务器。

一种更可靠的方法是使用分离接口创建迭代器：

interface BarIterator {

  1: GetNext() -> (vector<Bar> bars);

};

interface ChannelBasedGetter {

  1: GetBars(request<BarIterator> iterator);

};

调用 GetBars之后，客户端使用接口请求流水通道将第一个GetNext 调用立即排队。 此后，客户端反复调用GetNext 以从服务器读取其他数据，以限制未完成的GetNext 消息的数量以提供流控制。 注意，迭代器不需要“完成”响应，因为服务器可以使用空vector进行回复，然后在完成后关闭迭代器。

分页读取的另一种方法是使用令牌。 在这种方法中，服务器以不透明令牌的形式将迭代器状态存储在客户端上，并且每次读取部分内容时，客户端会将令牌返回给服务器：

struct Token { array<uint8>:16 opaque; }

interface TokenBasedGetter {

 // If token is null, fetch the first N entries. If token is not null, return the N items starting at token

 // Returns as many entries as it can in results and populates next_token if more entries are available.

 1: GetEntries(Token? token) -> (vector<Entry> entries, Token? next_token);

}

当服务器可以将其所有分页状态都托管给客户端，因此根本不再需要保持分页状态时，此模式非常实用的。 服务器应记录客户端是否可以保留令牌并在接口实例之间重用令牌。 安全说明：无论哪种情况，服务器都必须验证客户端提供的令牌，以确保客户端的访问仅限于其自身的分页结果，并且不包括用于其他客户端的结果。

**事件对关联模式**

使用客户端分配的标识符时，客户端使用仅在其自身与服务器的连接的上下文中才有意义的标识符来标识服务器拥有的对象。 但是，某些用例需要跨客户端关联对象。 例如，在fuchsia.ui.scenic,中，客户端使用客户端分配的标识符在很大程度上与场景图中的节点进行交互。 但是，从另一个流程导入节点需要跨该流程边界关联对该节点的引用。

事件对关联模式通过依赖内核提供必要的安全性，使用前向反馈数据流解决了此问题。 首先，希望导出对象的客户端创建一个zx::eventpair ，并将纠缠的事件之一及其由客户端分配的对象标识符发送到服务器。 然后，客户端将另一个纠缠的事件发送给另一个客户端，该事件将事件与具有自己的客户端分配的标识符（现在共享对象）的事件转发给服务器：

interface Foo {

  1: ExportThing(uint32 client_assigned_id, ..., handle<eventpair> export_token);

};

interface Bar {

  1: ImportThing(uint32 some_other_client_assigned_id, ..., handle<eventpair> import_token);

};

为了关联对象，服务器使用zx_object_get_info调用ZX_INFO_HANDLE_BASIC并匹配纠缠事件对象的 koid和related_koid 属性。

**取消事件对关联模式**

使用剥离事务时，客户端可以通过关闭接口的客户端来取消长时间运行的操作。 服务器应侦听ZX_CHANNEL_PEER_CLOSED 并中止事务以避免浪费资源

没有专用通道的操作也有类似的用例。 例如，[fuchsia.net.http.Loader](http://fuchsia.net.http.Loader)接口具有启动HTTP请求的Fetch方法。 HTTP事务完成后，服务器将使用HTTP响应回复请求，这可能会花费大量时间。 除非关闭整个Loader接口，否则客户端没有明显的方法来取消请求，这可能会取消许多其他未完成的请求。

事件对取消模式通过让客户端包括来自zx::eventpair 的纠缠事件之一作为方法的参数来解决此问题。 然后，服务器侦听ZX_EVENTPAIR_PEER_CLOSED并在断言该信号时取消操作。 使用zx::eventpair 比使用zx::event或其他信号更好，因为zx::eventpair方法可隐式处理客户端崩溃的情况或者直接关闭因为当纠缠在一起时内核会自动生成ZX_EVENTPAIR_PEER_CLOSED客户端保留的事件被销毁。

**空接口**

有时，空接口也可以提供价值。 例如，创建对象的方法可能还会收到request<FooController> 参数。 调用方提供了此空接口的实现：

interface FooController {};

FooController 不包含任何控制所创建对象的方法，但是服务端可以使用接口上的ZX_CHANNEL_PEER_CLOSED信号来触发销毁对象。 将来，该接口可能会使用用于控制创建的对象的方法进行扩展。

**反模式**

本节描述了几种反模式：通常提供消极影响的设计模式。 学习识别这些模式是避免以错误的方式使用它们的第一步。

**客户端库**

理想情况下，客户端使用FIDL编译器生成的特定于语言的客户端库与FIDL中定义的协议进行交互。 这种方法可以让Fuchsia为大量目标语言提供高质量的支持，但是有时协议过于底层而无法直接进行编程，因此手写的客户端库适合提供与更简单的同一基础协议的接口。 那样更容易正确使用。

例如，[fuchsia.io](http://fuchsia.io)有一个客户端库[libfdio.so](http://libfdio.so)，它为协议提供了类似POSIX的前端协议。 希望使用POSIX风格的open/close/read/write 接口的客户端可以链接到[libfdio.so](http://libfdio.so)并以最小的代价改动[fuchsia.io](http://fuchsia.io)协议。 该客户端库提供有效的价值，因为该库可在现有库接口和基础FIDL协议之间进行调整。

提供积极效果的另一种客户端库是框架。 框架是一个广泛的客户端库，它为大部分应用程序提供结构。 通常，框架通过多种协议集提供大量抽象。 例如，Flutter是一个框架，可以看作fuchsia.ui 协议的扩展客户端库。

无论该协议是否具有关联的客户端库，都应完整记录FIDL协议。 一个独立的软件工程师小组应该能够直接根据给定的协议定义来理解和正确使用该协议，而无需对客户端库进行反向工程。 当协议具有客户端库时，应清楚记录协议的底层和足以激发您创建客户端库的细节方面。

客户端库的主要困难是需要针对每种目标语言进行维护，这往往意味着缺少流行语言的客户端库（（或质量较低））。 客户端库还倾向于使底层协议变得僵化，因为它们使每个客户端以完全相同的方式与服务器交互。 当客户端偏离客户端库使用的模式时，服务器会期望这种确切的交互模式，并且无法正常工作。

为了在Fuchsia SDK中包含客户端库，我们应该至少以两种语言提供该库的实现。

**服务中心**

服务中心是一个Discoverable ，它使您可以发现许多其他接口，通常使用显式名称：

BAD:

[Discoverable]

interface ServiceHub {

  1: GetFoo(request<Foo> foo);

  2: GetBar(request<Bar> bar);

  3: GetBaz(request<Baz> baz);

  4: GetQux(request<Qux> qux);

};

尤其是在无状态的情况下，ServiceHub接口不能提供比简单地使单个服务可直接发现更有价值:

[Discoverable]

interface Foo { ... };

[Discoverable]

interface Bar { ... };

[Discoverable]

interface Baz { ... };

[Discoverable]

interface Qux { ... };

无论哪种方式，客户端都可以建立与枚举服务的连接。 在后一种情况下，客户端可以通过整个系统中用于发现服务的常规机制发现相同的服务。 使用常规机制，可使核心平台将适当的策略应用于发现

但是，服务中心在某些情况下可能很有用。 例如，如果接口是有状态的，或者是通过比正常服务发现更复杂的过程获得的，则接口可以通过将状态转移到获得的服务来提供值。 作为另一个示例，如果用于获取服务的方法采用其他参数，则接口可以在连接到服务时通过考虑这些参数来提供值。

**过度的面向对象设计**

一些库为协议中的每个逻辑对象创建单独的接口实例，但是这种方法有许多缺点：

- 未定义不同接口实例之间的消息顺序。 通过单个接口发送的消息按FIFO顺序（在每个方向上）进行处理，但是通过不同通道发送的消息会争用。 当客户端和服务器之间的交互分布在许多通道上时，如果消息意外地重新排序，则存在更大的潜在错误。
- 每个接口实例在内核资源，等待队列和调度方面都有代价。 尽管Fuchsia被设计为可扩展到大量通道，但是成本在整个系统上加起来，并且创建大量对象来建模系统中的每个逻辑对象给系统带来了沉重负担。
- 错误处理和拆除的复杂性要大得多，因为错误和拆除状态的数量会随着交互中涉及的接口实例的数量呈指数增长。 当您使用单个接口实例时，客户端和服务器都可以通过关闭接口来干脆地关闭交互。 使用多个接口实例，交互可以进入交互被部分关闭的状态，或者两方对关闭状态的统一不一致的状态时。
- 跨越接口边界的协调比在单个接口中进行协调更为复杂，因为涉及多个接口的协议需要考虑到不同客户端可能会使用不同接口的可能性，这些客户端可能不会完全相互可靠。

但是，存在将功能划分为多个接口的用例：

- 提供单独的接口可能对安全性有益，因为某些客户端可能只能访问其中一个接口，从而限制了它们与服务器的交互。
- 单独的接口也可以更容易地从单独的线程中使用。 例如，一个接口可能绑定到一个线程，而另一个接口可能绑定到另一个线程。
- 客户端和服务器为接口中的每种方法支付（少量）成本。 如果一次只需要几个较小的接口，那么拥有一个包含所有可能方法的巨型接口可能会比拥有多个较小的接口效率低。
- 有时，服务器保留的状态会沿着方法边界清晰地分解。 在这些情况下，请考虑将接口分解为沿着相同边界的较小接口，以提供用于与单独状态进行交互的单独接口。
- 

避免过度面向对象的一种好方法是使用客户端分配的标识符在协议中对逻辑对象进行建模。 这种模式使客户端可以通过单个接口与一组潜在的大量逻辑对象进行交互。