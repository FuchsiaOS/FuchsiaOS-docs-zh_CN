<!--
# Compiler Interface
-->
# FIDL 编译器界面

<!--
This document describes the command-line interface to the FIDL compiler.
-->
本文档描述了 FIDL 编译器的命令行界面。

<!--
Information on the internals of that tool lives
[alongside the source of the tool](../../system/host/fidl/README.md).
-->
有关该工具的内部信息[与其源码放在一起](../../system/host/fidl/README.md)。

<!--
See [Overview](../intro/README.md) for more information about FIDL's overall
purpose, goals, and requirements, as well as links to related documents.
-->
有关 FIDL 的总体目的，目标和要求以及相关文档链接的更多信息，请参阅 FIDL 概述。

<!--
## Overview
-->
## 概述

<!--
The FIDL compiler is split into a frontend and a number of backends. The
compiler processes one library at a time. The frontend consumes the FIDL
declarations for the library (as well as for all transitive dependencies),
performs semantic analysis, and outputs an intermediate representation of the
library. The backends consume the intermediate representation and generate
language-specific bindings for the library.
-->
FIDL 编译器分为前端和多个后端。编译器一次处理一个库。前端使用库的 FIDL 声明（以及所有传递性的依赖），执行语义分析，并输出库的中间表示。后端使用中间表示并为库生成特定语言的绑定。

<!--
## Frontend
-->
## 前端

<!--
The frontend is a command-line program named `fidlc`. The `fidlc` compiler takes
a number of arguments:
-->
前端是名为 `fidlc` 的命令行程序。 `fidlc` 编译器有多个参数：

<!--
 * `--c-header HEADER_PATH`. If present, this flag instructs `fidlc` to output
   a C header at the given path. In principle, the C header generation could
   have been implemented as a C backend, but for some practical reasons, we
   integrated the C header generation directly into the frontend.
-->
 * `--c-header HEADER_PATH`。如果该参数存在，则标识  `fidlc` 在给定路径里输出 C 语言头文件。 原则上，C 语言头文件的生成可在 C 的后端中得以实现，但出于某些实际原因，我们将其生成直接集成到前端。
<!--
 * `--tables TABLES_PATH`. If present, this flag instructs `fidlc` to output
   coding tables at the given path. The coding tables are required to encode and
   decode messages from the C and C++ bindings.
-->
 * `--tables TABLES_PATH`。如果该参数存在，则标识 `fidlc` 在给定路径里输出编码表。
   编码表的功能是编码和解码来自 C 和 C++ 绑定的消息。
<!--
 * `--json JSON_PATH`. If present, this flag instructs `fidlc` to output the
   library's intermediate representation at the given path. The intermediate
   representation is JSON that conforms to [a particular schema](../../system/host/fidl/schema.json).
   The intermediate representation is used as input to the various backends.
-->
 * `--json JSON_PATH`。如果该参数存在，则标识 `fidlc` 在给定路径里输出库的中间表示。中间表示是符合[特定模式](https://github.com/fuchsia-mirror/zircon/blob/master/system/host/fidl/schema.json)的JSON文件。中间表示的功能是，作为各种后端的输入。
<!--
 * `--name LIBRARY_NAME`. If present, this flag instructs `fidlc` to validate
   that the library being compiled has the given name. This flag is useful to
   cross-check between the library's declaration in a build system and the
   actual contents of the library.
-->
 * `--name LIBRARY_NAME`。如果该参数存在，则标识 `fidlc` 验证正在编译的库是否具有给定名称。此标志可用于在构建系统中的库声明与库的实际内容之间进行交叉检查。
 <!--
 * `--files [FIDL_FILE...]...`. Each `--file [FIDL_FILE...]` chunk of arguments
   describes a library, all of which must share the same top-level library name
   declaration. Libraries must be presented in dependency order, with later
   libraries able to use declarations from preceding libraries but not vice versa.
   Output is only generated for the final library, not for each of its dependencies.
-->
 * `--files [FIDL_FILE ...] ...`。每个 `--file [FIDL_FILE ...]` 参数块都描述了一个库，所有这些库都必须共享相同的顶级库名声明。库的名字必须以依赖的顺序传入，后面的库可使用前面库中的声明，但反之则不能。编译的结果是仅输出最后一个库的生成内容，而不是为每个依赖项生成输出。

<!--
All of the arguments can also be provided via a response file, denoted as
`@responsefile`. The contents of the file at `responsefile` will be interpreted
as a whitespace-delimited list of arguments. Response files cannot be nested,
and must be the only argument.
-->
上述所有的参数也可以通过响应文件的方式提供，并表示为 `@responsefile`。`responsefile` 文件的内容将被解释为以空格分隔的参数列表。另外，响应文件不能相互嵌套，并且必须是唯一的参数。

<!--
## Backend
-->
## 后端

<!--
The backend is a command-line program named `fidlgen`. The `fidlgen` compiler
takes a number of arguments:
-->
后端是一个名为 `fidlgen` 的命令行程序。`fidlgen` 编译器也有多个参数：

<!--
 * `--json` (required). The path to the intermediate representation of the
   library. The intermediate representation is JSON that conforms to
   [a particular schema](../../system/host/fidl/schema.json).
-->
 * `--json`（必填），FIDL库中间表示的文件路径，中间表示是符合[特定模式](https://github.com/fuchsia-mirror/zircon/blob/master/system/host/fidl/schema.json)的 JSON 文件。
  
<!--
 * `--generators` (required). A comma-separated list of generators to run on the
   given library. The following generators are currently supported: `cpp`, `go`,
   `dart`, and `rust`.
-->
 * `--generators`（必填）。在给定的 FIDL库上运行的生成器列表，以逗号分隔。目前支持以下语言的生成器：`cpp`，`go`，`dart` 和 `rust`。

<!--
 * `--output-base` (required). The base file name for files generated by this
   generator. The generator will create files by adding extensions to this file
   name. For example, the `cpp` backend generates two files, one with the `.h`
   extension and another with the `.cc` extension.
-->

* `--output-base`（必填）。生成的文件（不包含扩展名）的基本文件名，生成器将通过添加此文件名的扩展名来创建文件。例如，`cpp` 后端会生成两个文件，一个带有 `.h` 扩展名，另一个带有 `.cc` 扩展名。

<!--
 * `--include-base` (required). The base directory relative to which C and C++
   `#include` directives should be computed. For example, when the `cpp` backend
   generates an `#include` directive to reference the `.h` file from the `.cc`
   file, the backend will create the `#include` path relative to this directory.
-->
 * `--include-base`（必填）。在计算 C 和 C++ 的 `#include` 指令时，相对于的基础目录。例如，当 `cpp` 后端生成 `#include` 指令在 `.cc` 文件中引用 `.h` 文件时，后端将创建相对于该目录的 `#include` 路径。

<!--
## Limitations
-->
## 限制

<!--
For the `cpp` backend, the generated `.h` file must be includeable as
`#include <fuchsia/cpp/$LIBRARY_NAME.h>`, where `$LIBRARY_NAME` is the name of
the corresponding FIDL library. Typically, that means that the `--output-base`
flag will have the value `$INCLUDE_BASE/fuchsia/cpp/$LIBRARY_NAME`, where
`$INCLUDE_BASE` is the value of the `--include-base` flag.
-->
对于 `cpp` 后端，生成的 `.h` 文件必须以 `#include <fuchsia/cpp/$LIBRARY_NAME.h>` 的形式包含，其中 `$LIBRARY_NAME` 是相应 FIDL 库的名称。通常，这意味着 `--output-base` 标志具有 `$INCLUDE_BASE/fuchsia/cpp/$LIBRARY_NAME` 值，其中 `$INCLUDE_BASE` 是 `--include-base` 标志的值。