<!-- WARNING: This file is machine generated by //src/tests/fidl/source_compatibility/gen, do not edit. -->

Note: This document covers API impact only. For more details, see the
[ABI compatibility page](/docs/development/languages/fidl/guides/compatibility/README.md)

# Remove a protocol event

## Overview

-|[init](#init)|[step 1](#step-1)|[step 2](#step-2)|[step 3](#step-3)|[step 4](#step-4)
---|---|---|---|---|---
fidl|[link](#fidl-init)|[link](#fidl-1)||[link](#fidl-3)|
dart|[link](#dart-init)||[link](#dart-2)||
go|[link](#go-init)||[link](#go-2)||
hlcpp|[link](#hlcpp-init)||[link](#hlcpp-2)||
llcpp|[link](#llcpp-init)||[link](#llcpp-2)||
rust|[link](#rust-init)||[link](#rust-2)||[link](#rust-4)

## Initial State {#init}

### FIDL {#fidl-init}

```fidl
protocol Example {
    -> OnExistingEvent();
    -> OnOldEvent();
};
```

### Dart {#dart-init}

```dart
class Server extends fidllib.Example {
  final _onExistingEventStreamController = StreamController<void>();
  final _onOldEventStreamController = StreamController<void>();

  @override
  Stream<void> get onExistingEvent => _onExistingEventStreamController.stream;

  @override
  Stream<void> get onOldEvent => _onOldEventStreamController.stream;
}

void expectEvents(fidllib.ExampleProxy client) async {
  await client.onExistingEvent.first;
  await client.onOldEvent.first;
}
```

### Go {#go-init}

```go
func expectEvents(c *lib.ExampleWithCtxInterface) {
	_ = c.ExpectOnExistingEvent(context.Background())
	_ = c.ExpectOnOldEvent(context.Background())
}

func sendEvents(p *lib.ExampleEventProxy) {
	_ = p.OnExistingEvent()
	_ = p.OnOldEvent()
}

```

### HLCPP {#hlcpp-init}

```cpp
void expectEvents(fidl_test::ExamplePtr* client) {
  client->events().OnExistingEvent = []() {};
  client->events().OnOldEvent = []() {};
}

void sendEvents(fidl::Binding<fidl_test::Example>* server) {
  server->events().OnExistingEvent();
  server->events().OnOldEvent();
}
```

### LLCPP {#llcpp-init}

```cpp
class AsyncEventHandler : public fidl::WireAsyncEventHandler<fidl_test::Example> {
  void OnExistingEvent(fidl::WireResponse<fidl_test::Example::OnExistingEvent>* event) override {}
  void OnOldEvent(fidl::WireResponse<fidl_test::Example::OnOldEvent>* event) override {}
};

class SyncEventHandler : public fidl::WireSyncEventHandler<fidl_test::Example> {
  void OnExistingEvent(fidl::WireResponse<fidl_test::Example::OnExistingEvent>* event) override {}
  void OnOldEvent(fidl::WireResponse<fidl_test::Example::OnOldEvent>* event) override {}
};

void sendEvents(fidl::ServerBindingRef<fidl_test::Example> server) {
  server->OnExistingEvent();
  server->OnOldEvent();
}
```

### Rust {#rust-init}

```rust
fn send_events(stream: fidl_lib::ExampleRequestStream) -> Result<(), fidl::Error> {
    let control_handle = stream.control_handle();
    control_handle.send_on_existing_event()?;
    control_handle.send_on_old_event()?;
    Ok(())
}

async fn receive_events(client: fidl_lib::ExampleProxy) -> Result<(), fidl::Error> {
    let mut event_stream = client.take_event_stream();
    while let Some(event) = event_stream.try_next().await? {
        match event {
            fidl_lib::ExampleEvent::OnExistingEvent { .. } => {}
            fidl_lib::ExampleEvent::OnOldEvent { .. } => {}
        }
    }
    Ok(())
}
```

## Update FIDL Library {#step-1}

- Mark the method that is being removed with the `[Transitional]` attribute.

```diff
  protocol Example {
      -> OnExistingEvent();
+     @transitional
      -> OnOldEvent();
  };

```

## Update Source Code {#step-2}

### Dart {#dart-2}

- Remove implementations of the event stream
- Stop handling the event on the client side.

```diff
  class Server extends fidllib.Example {
    final _onExistingEventStreamController = StreamController<void>();
-   final _onOldEventStreamController = StreamController<void>();
  
    @override
    Stream<void> get onExistingEvent => _onExistingEventStreamController.stream;
- 
-   @override
-   Stream<void> get onOldEvent => _onOldEventStreamController.stream;
  }
  
  void expectEvents(fidllib.ExampleProxy client) async {
    await client.onExistingEvent.first;
-   await client.onOldEvent.first;
  }

```

### Go {#go-2}

- Remove usages of the event.

```diff
  func expectEvents(c *lib.ExampleWithCtxInterface) {
  	_ = c.ExpectOnExistingEvent(context.Background())
- 	_ = c.ExpectOnOldEvent(context.Background())
  }
  
  func sendEvents(p *lib.ExampleEventProxy) {
  	_ = p.OnExistingEvent()
- 	_ = p.OnOldEvent()
  }
  

```

### HLCPP {#hlcpp-2}

- Remove any uses of the event being removed.

```diff
  void expectEvents(fidl_test::ExamplePtr* client) {
    client->events().OnExistingEvent = []() {};
-   client->events().OnOldEvent = []() {};
  }
  
- void sendEvents(fidl::Binding<fidl_test::Example>* server) {
-   server->events().OnExistingEvent();
-   server->events().OnOldEvent();
- }
+ void sendEvents(fidl::Binding<fidl_test::Example>* server) { server->events().OnExistingEvent(); }

```

### LLCPP {#llcpp-2}

- Remove any uses of the event being removed.

```diff
  class AsyncEventHandler : public fidl::WireAsyncEventHandler<fidl_test::Example> {
    void OnExistingEvent(fidl::WireResponse<fidl_test::Example::OnExistingEvent>* event) override {}
-   void OnOldEvent(fidl::WireResponse<fidl_test::Example::OnOldEvent>* event) override {}
  };
  
  class SyncEventHandler : public fidl::WireSyncEventHandler<fidl_test::Example> {
    void OnExistingEvent(fidl::WireResponse<fidl_test::Example::OnExistingEvent>* event) override {}
-   void OnOldEvent(fidl::WireResponse<fidl_test::Example::OnOldEvent>* event) override {}
  };
  
- void sendEvents(fidl::ServerBindingRef<fidl_test::Example> server) {
-   server->OnExistingEvent();
-   server->OnOldEvent();
- }
+ void sendEvents(fidl::ServerBindingRef<fidl_test::Example> server) { server->OnExistingEvent(); }

```

### Rust {#rust-2}

- Add `#[allow(unreachable_patterns)]` to any client event stream match statements, and replace the arm for the event being removed with a catch-all (`_`) arm.
- Servers should stop sending the event.

```diff
  fn send_events(stream: fidl_lib::ExampleRequestStream) -> Result<(), fidl::Error> {
      let control_handle = stream.control_handle();
      control_handle.send_on_existing_event()?;
-     control_handle.send_on_old_event()?;
      Ok(())
  }
  
  async fn receive_events(client: fidl_lib::ExampleProxy) -> Result<(), fidl::Error> {
      let mut event_stream = client.take_event_stream();
      while let Some(event) = event_stream.try_next().await? {
+         #[allow(unreachable_patterns)]
          match event {
              fidl_lib::ExampleEvent::OnExistingEvent { .. } => {}
-             fidl_lib::ExampleEvent::OnOldEvent { .. } => {}
+             _ => {}
          }
      }
      Ok(())
  }

```

## Update FIDL Library {#step-3}

- Remove the `[Transitional]` attribute.

```diff
  protocol Example {
      -> OnExistingEvent();
-     @transitional
-     -> OnOldEvent();
  };

```

## Update Source Code {#step-4}

### Rust {#rust-4}

- Remove `#[allow(unreachable_patterns)]` and the catch-all arm.

```diff
  fn send_events(stream: fidl_lib::ExampleRequestStream) -> Result<(), fidl::Error> {
      let control_handle = stream.control_handle();
      control_handle.send_on_existing_event()?;
      Ok(())
  }
  
  async fn receive_events(client: fidl_lib::ExampleProxy) -> Result<(), fidl::Error> {
      let mut event_stream = client.take_event_stream();
      while let Some(event) = event_stream.try_next().await? {
-         #[allow(unreachable_patterns)]
          match event {
              fidl_lib::ExampleEvent::OnExistingEvent { .. } => {}
-             _ => {}
          }
      }
      Ok(())
  }

```

