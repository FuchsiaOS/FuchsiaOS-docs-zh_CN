<!-- WARNING: This file is machine generated by //src/tests/fidl/source_compatibility/gen, do not edit. -->

Note: This document covers API impact only. For more details, see the
[ABI compatibility page](/docs/development/languages/fidl/guides/compatibility/README.md)

# Add a bits member

## Overview

-|[init](#init)|[step 1](#step-1)|[step 2](#step-2)
---|---|---|---
fidl|[link](#fidl-init)|[link](#fidl-1)|
dart|[link](#dart-init)||[link](#dart-2)
go|[link](#go-init)||[link](#go-2)
hlcpp|[link](#hlcpp-init)||[link](#hlcpp-2)
llcpp|[link](#llcpp-init)||[link](#llcpp-2)
rust|[link](#rust-init)||[link](#rust-2)

## Initial State {#init}

### FIDL {#fidl-init}

```fidl
type Flags = flexible bits {
    OPTION_A = 1;
    OPTION_B = 2;
};
```

### Dart {#dart-init}

```dart
void useBits(fidllib.Flags bits) {
  if ((bits & fidllib.Flags.optionA).$value != 0) {
    print('option A is set');
  }
  if ((bits & fidllib.Flags.optionB).$value != 0) {
    print('option B is set');
  }
  if (bits.hasUnknownBits()) {
    print('unknown options: ${bits.getUnknownBits()}');
  }
}
```

### Go {#go-init}

```go
func useBits(bits lib.Flags) {
	if bits.HasBits(lib.FlagsOptionA) {
		fmt.Println("option C is set")
	}
	if bits.HasBits(lib.FlagsOptionB) {
		fmt.Println("option C is set")
	}
	if bits.HasUnknownBits() {
		fmt.Printf("unknown options: 0x%x", bits.GetUnknownBits())
	}
}

```

### HLCPP {#hlcpp-init}

```cpp
void use_member(fidl_test::Flags bits) {
  if (bits & fidl_test::Flags::OPTION_A) {
    printf("option A is set\n");
  }
  if (bits & fidl_test::Flags::OPTION_B) {
    printf("option B is set\n");
  }
  if (bits.has_unknown_bits()) {
    printf("unknown options: 0x%04x", uint32_t(bits.unknown_bits()));
  }
}
```

### LLCPP {#llcpp-init}

```cpp
void use_bits(fidl_test::wire::Flags bits) {
  if (bits & fidl_test::wire::Flags::kOptionA) {
    printf("option A is set\n");
  }
  if (bits & fidl_test::wire::Flags::kOptionB) {
    printf("option B is set\n");
  }
  if (bits.has_unknown_bits()) {
    printf("unknown options: 0x%04x", uint32_t(bits.unknown_bits()));
  }
}
```

### Rust {#rust-init}

```rust
fn use_bits(bits: &fidl_lib::Flags) {
    if bits.contains(fidl_lib::Flags::OptionA) {
        println!("option A is set");
    }
    if bits.contains(fidl_lib::Flags::OptionB) {
        println!("option B is set");
    }
    if bits.has_unknown_bits() {
        println!("unknown options: {:x}", bits.get_unknown_bits());
    }
}
```

## Update FIDL Library {#step-1}

- Add the new member

```diff
  type Flags = flexible bits {
      OPTION_A = 1;
      OPTION_B = 2;
+     OPTION_C = 4;
  };

```

## Update Source Code {#step-2}

### Dart {#dart-2}

- You can now use the new member

```diff
  void useBits(fidllib.Flags bits) {
    if ((bits & fidllib.Flags.optionA).$value != 0) {
      print('option A is set');
    }
    if ((bits & fidllib.Flags.optionB).$value != 0) {
      print('option B is set');
    }
+   if ((bits & fidllib.Flags.optionC).$value != 0) {
+     print('option C is set');
+   }
    if (bits.hasUnknownBits()) {
      print('unknown options: ${bits.getUnknownBits()}');
    }
  }

```

### Go {#go-2}

- You can now use the new member

```diff
  func useBits(bits lib.Flags) {
  	if bits.HasBits(lib.FlagsOptionA) {
  		fmt.Println("option C is set")
  	}
  	if bits.HasBits(lib.FlagsOptionB) {
  		fmt.Println("option C is set")
  	}
+ 	if bits.HasBits(lib.FlagsOptionC) {
+ 		fmt.Println("option C is set")
+ 	}
  	if bits.HasUnknownBits() {
  		fmt.Printf("unknown options: 0x%x", bits.GetUnknownBits())
  	}
  }
  

```

### HLCPP {#hlcpp-2}

- You can now use the new member

```diff
  void use_member(fidl_test::Flags bits) {
    if (bits & fidl_test::Flags::OPTION_A) {
      printf("option A is set\n");
    }
    if (bits & fidl_test::Flags::OPTION_B) {
      printf("option B is set\n");
    }
+   if (bits & fidl_test::Flags::OPTION_C) {
+     printf("option C is set\n");
+   }
    if (bits.has_unknown_bits()) {
      printf("unknown options: 0x%04x", uint32_t(bits.unknown_bits()));
    }
  }

```

### LLCPP {#llcpp-2}

- You can now use the new member

```diff
  void use_bits(fidl_test::wire::Flags bits) {
    if (bits & fidl_test::wire::Flags::kOptionA) {
      printf("option A is set\n");
    }
    if (bits & fidl_test::wire::Flags::kOptionB) {
      printf("option B is set\n");
    }
+   if (bits & fidl_test::wire::Flags::kOptionC) {
+     printf("option C is set\n");
+   }
    if (bits.has_unknown_bits()) {
      printf("unknown options: 0x%04x", uint32_t(bits.unknown_bits()));
    }
  }

```

### Rust {#rust-2}

- You can now use the new member

```diff
  fn use_bits(bits: &fidl_lib::Flags) {
      if bits.contains(fidl_lib::Flags::OptionA) {
          println!("option A is set");
      }
      if bits.contains(fidl_lib::Flags::OptionB) {
          println!("option B is set");
      }
+     if bits.contains(fidl_lib::Flags::OptionC) {
+         println!("option C is set");
+     }
      if bits.has_unknown_bits() {
          println!("unknown options: {:x}", bits.get_unknown_bits());
      }
  }

```

