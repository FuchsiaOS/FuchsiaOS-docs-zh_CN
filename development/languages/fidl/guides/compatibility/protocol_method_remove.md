<!-- WARNING: This file is machine generated by //src/tests/fidl/source_compatibility/gen, do not edit. -->

Note: This document covers API impact only. For more details, see the
[ABI compatibility page](development/languages/fidl/guides/compatibility/README.md)

# Remove a protocol method

## Overview

-|[init](#init)|[step 1](#step-1)|[step 2](#step-2)|[step 3](#step-3)|[step 4](#step-4)
---|---|---|---|---|---
fidl|[link](#fidl-init)|[link](#fidl-1)||[link](#fidl-3)|
dart|[link](#dart-init)||[link](#dart-2)||
go|[link](#go-init)||[link](#go-2)||[link](#go-4)
hlcpp|[link](#hlcpp-init)||[link](#hlcpp-2)||
llcpp|[link](#llcpp-init)||[link](#llcpp-2)||
rust|[link](#rust-init)||[link](#rust-2)||[link](#rust-4)

## Initial State {#init}

### FIDL {#fidl-init}

```fidl
protocol Example {
    ExistingMethod();
    OldMethod();
};
```

### Dart {#dart-init}

```dart
class Server extends fidllib.Example {
  @override
  Future<void> existingMethod() async {}

  @override
  Future<void> oldMethod() async {}
}

void client(fidllib.ExampleProxy client) async {
  await client.existingMethod();
  await client.oldMethod();
}
```

### Go {#go-init}

```go
type client struct {
	removeMethod *lib.ExampleWithCtxInterface
}

func (c client) test() {
	c.removeMethod.ExistingMethod(context.Background())
	c.removeMethod.OldMethod(context.Background())
}

type server struct{}

// Assert that server implements the Example interface
var _ lib.ExampleWithCtx = &server{}

func (*server) ExistingMethod(fidl.Context) error {
	return nil
}

func (*server) OldMethod(fidl.Context) error {
	return nil
}

```

### HLCPP {#hlcpp-init}

```cpp
class Server : public fidl_test::Example {
  void ExistingMethod() final {}
  void OldMethod() final {}
};

void client(fidl_test::ExamplePtr client) {
  client->ExistingMethod();
  client->OldMethod();
}
```

### LLCPP {#llcpp-init}

```cpp
class Server final : public fidl::WireServer<fidl_test::Example> {
 public:
  void ExistingMethod(ExistingMethodRequestView request,
                      ExistingMethodCompleter::Sync& completer) final {}
  void OldMethod(OldMethodRequestView request, OldMethodCompleter::Sync& completer) final {}
};

void client(fidl::WireClient<fidl_test::Example> client) {
  client->ExistingMethod();
  client->OldMethod();
}
```

### Rust {#rust-init}

```rust
struct ExampleFakeProxy;

impl fidl_lib::ExampleProxyInterface for ExampleFakeProxy {
    fn existing_method(&self) -> Result<(), fidl::Error> {
        Ok(())
    }
    fn old_method(&self) -> Result<(), fidl::Error> {
        Ok(())
    }
}

async fn example_service(chan: fasync::Channel) -> Result<(), fidl::Error> {
    let mut stream = fidl_lib::ExampleRequestStream::from_channel(chan);
    while let Some(req) = stream.try_next().await? {
        match req {
            fidl_lib::ExampleRequest::ExistingMethod { .. } => {}
            fidl_lib::ExampleRequest::OldMethod { .. } => {}
        }
    }
    Ok(())
}
```

## Update FIDL Library {#step-1}

- Mark the method that is being removed with the `[Transitional]` attribute.

```diff
  protocol Example {
      ExistingMethod();
+     @transitional
      OldMethod();
  };

```

## Update Source Code {#step-2}

### Dart {#dart-2}

- Remove references to the method in client code and server code.

```diff
  class Server extends fidllib.Example {
    @override
    Future<void> existingMethod() async {}
- 
-   @override
-   Future<void> oldMethod() async {}
  }
  
  void client(fidllib.ExampleProxy client) async {
    await client.existingMethod();
-   await client.oldMethod();
  }

```

### Go {#go-2}

- Embed the protocol's `WithCtxTransitionBase` struct into the server type.
- Remove the implementation for the method being removed from the server.
- Remove any references to the method in client code (e.g. request calls being made)

```diff
  type client struct {
  	removeMethod *lib.ExampleWithCtxInterface
  }
  
  func (c client) test() {
  	c.removeMethod.ExistingMethod(context.Background())
- 	c.removeMethod.OldMethod(context.Background())
  }
  
- type server struct{}
+ type server struct {
+ 	lib.ExampleWithCtxInterface
+ }
  
  // Assert that server implements the Example interface
  var _ lib.ExampleWithCtx = &server{}
  
  func (*server) ExistingMethod(fidl.Context) error {
  	return nil
  }
  
- func (*server) OldMethod(fidl.Context) error {
- 	return nil
- }
- 

```

### HLCPP {#hlcpp-2}

- Remove references to the method in client code and server code.

```diff
  class Server : public fidl_test::Example {
    void ExistingMethod() final {}
-   void OldMethod() final {}
  };
  
- void client(fidl_test::ExamplePtr client) {
-   client->ExistingMethod();
-   client->OldMethod();
- }
+ void client(fidl_test::ExamplePtr client) { client->ExistingMethod(); }

```

### LLCPP {#llcpp-2}

- Remove references to the method in client code and server code.

```diff
  class Server final : public fidl::WireServer<fidl_test::Example> {
   public:
    void ExistingMethod(ExistingMethodRequestView request,
                        ExistingMethodCompleter::Sync& completer) final {}
-   void OldMethod(OldMethodRequestView request, OldMethodCompleter::Sync& completer) final {}
  };
  
- void client(fidl::WireClient<fidl_test::Example> client) {
-   client->ExistingMethod();
-   client->OldMethod();
- }
+ void client(fidl::WireClient<fidl_test::Example> client) { client->ExistingMethod(); }

```

### Rust {#rust-2}

- Add #[allow(unreachable_patterns)] to the server's request stream match.
- Replace the match arm for the method that is being removed with a catchall (`_`) arm.
- Remove any references to the method in client code (e.g. as part of implementations of the `ProxyInterface`).

```diff
  struct ExampleFakeProxy;
  
  impl fidl_lib::ExampleProxyInterface for ExampleFakeProxy {
      fn existing_method(&self) -> Result<(), fidl::Error> {
-         Ok(())
-     }
-     fn old_method(&self) -> Result<(), fidl::Error> {
          Ok(())
      }
  }
  
  async fn example_service(chan: fasync::Channel) -> Result<(), fidl::Error> {
      let mut stream = fidl_lib::ExampleRequestStream::from_channel(chan);
      while let Some(req) = stream.try_next().await? {
+         #[allow(unreachable_patterns)]
          match req {
              fidl_lib::ExampleRequest::ExistingMethod { .. } => {}
-             fidl_lib::ExampleRequest::OldMethod { .. } => {}
+             _ => {}
          }
      }
      Ok(())
  }

```

## Update FIDL Library {#step-3}

- Remove the method.

```diff
  protocol Example {
      ExistingMethod();
-     @transitional
-     OldMethod();
  };

```

## Update Source Code {#step-4}

### Go {#go-4}

- Remove the embedded `WithCtxInterface` struct.

```diff
  type client struct {
  	removeMethod *lib.ExampleWithCtxInterface
  }
  
  func (c client) test() {
  	c.removeMethod.ExistingMethod(context.Background())
  }
  
- type server struct {
- 	lib.ExampleWithCtxInterface
- }
+ type server struct{}
  
  // Assert that server implements the Example interface
  var _ lib.ExampleWithCtx = &server{}
  
  func (*server) ExistingMethod(fidl.Context) error {
  	return nil
  }
  

```

### Rust {#rust-4}

- Remove the `#[allow(unreachable_patterns)]` attribute and the catch-all match arm.

```diff
  struct ExampleFakeProxy;
  
  impl fidl_lib::ExampleProxyInterface for ExampleFakeProxy {
      fn existing_method(&self) -> Result<(), fidl::Error> {
          Ok(())
      }
  }
  
  async fn example_service(chan: fasync::Channel) -> Result<(), fidl::Error> {
      let mut stream = fidl_lib::ExampleRequestStream::from_channel(chan);
      while let Some(req) = stream.try_next().await? {
-         #[allow(unreachable_patterns)]
          match req {
              fidl_lib::ExampleRequest::ExistingMethod { .. } => {}
-             _ => {}
          }
      }
      Ok(())
  }

```

