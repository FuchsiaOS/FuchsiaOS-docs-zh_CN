{% set rfcid = "RFC-0002" %}
{% include "docs/contribute/governance/rfcs/_common/_rfc_header.md" %}
# {{ rfc.name }}: {{ rfc.title }}
<!-- SET the `rfcid` VAR ABOVE. DO NOT EDIT ANYTHING ELSE ABOVE THIS LINE. -->

## 概括

本文档为Fuchsia平台提出了 *API版本(API level)* 和 *ABI版本(ABI revision)* 的概念。
终端开发人员根据 *目标API版本* 构建应用程序，该版本确定哪些声明对应用程序可见。
*目标API版本* 也被嵌入到已编译的应用程序中，作为一个 *目标ABI版本*，
表示应用程序期望从平台获得哪些语义支持。一个Fuchsia平台版本通常支持多个 *ABI版本*，
这样既支持了平台运行较旧的应用程序，同时又为平台的更新提供了途径。

## 动机

目前，Fuchsia平台通过一系列 *软过渡* 的方式逐步更新。
要改变一部分 [Fuchsia系统接口]，平台首先会引入新接口。
然后应用程序可以逐步迁移到新接口。在所有应用程序都迁移到新接口之后，
平台会移除旧接口。

通过这种方法，平台只能以最慢的速度更新。为了完成软过渡，
平台需要等待最后一个应用程序从旧接口迁移到新接口。
当应用程序数量增加，平台和应用程序之间的耦合减少，
*软过渡* 需要越来越长的时间来完成。最终，我们将无法使用 *软过渡* 来更新平台。

该 RFC 解决了以下问题陈述：

> 在较长的一段时间内，Fuchsia平台如何在支持越来越多的旧应用程序的同时, 保持平台的持续更新？

## 为什么现在？

我们的一些客户要求平台提供更高的稳定性。要是我们
现在提供这种稳定性，我们将放慢我们发展平台的能力。
为了满足这些当前的客户需求，平台需要能够
提供更长的兼容性窗口，而不会使项目停止。

此外，Windows 的经验是我们将从中受益
在被要求之前在应用程序中嵌入目标 ABI 修订
长期提供与这些应用程序的二进制兼容性。
Windows 错过了这个机会，现在尝试猜测目标 ABI 修订版
对于使用启发式的二进制文件，这会给开发人员带来很大的痛苦。

## 术语

Fuchsia 的 *release* 是 Fuchsia 操作系统的构建和相关联的
部署到用户群体的软件包。一个版本有一个版本号
标识发布中包含的软件工件集。

*向后兼容性*是指较新版本的 Fuchsia 能够
运行旨在在旧版本 Fuchsia 上运行的二进制文件。

*Fuchsia IDK* 是开发环境集成商用来
向开发人员公开 Fuchsia 平台以构建应用程序
在Fuchsia上运行。Fuchsia IDK 由 Fuchsia 项目发布并定义
Fuchsia 平台与在 Fuchsia 上运行的应用程序之间的合约。
IDK 工具定义了 Fuchsia IDK 工具和
开发环境集成商的环境。

*软过渡*是一种打破向后不兼容的技术
更改为对平台的一系列较小更改和一组已知的
二进制文件，以便在每一步本地维护兼容性。

## 设计

本文档中描述的设计是对 [Fuchsia System
Interface]，它让平台和应用程序就
应用程序期望从平台获得的语义。

具体来说，如果应用程序在给定的 Fuchsia 版本上运行，那么
应用程序应继续在 Fuchsia 的未来版本上工作，除非 Fuchsia
故意放弃对应用程序的支持。这个设计没有解决
创建适用于旧版本的新应用程序的相反问题
Fuchsia的。

### 版本控制

Fuchsia 平台使用两个版本标识符，一个 *API 级别* 和一个
*ABI 修订版*。这两个版本都标识了由
平台而不是该接口的*实现*。Fuchsia的发布
使用不同的版本控制方案，它标识了具体的实现
在那个版本中。

给定的 API 级别包含特定的 ABI 修订，但有多个 API 级别
可能涉及相同的 ABI 修订。

#### API 级别

Fuchsia *API 级别* 表示在构建一个 API 时可用的一组 API
应用。[Fuchsia IDK] 的给定版本通常支持多个
API 级别。在给定的受支持 API 级别上可用的 API 应该是
在 IDK 版本中保持一致。

> *示例。* 考虑 `pkg/fit`，它是 SDK 中的 C++ 库。“适合”
库声明了许多函数，每个函数都是由
图书馆。API 定义了这组函数，这意味着两个 IDK 版本
应该在同一 API 的 `fit` 库中公开相同的函数集
等级。

从语法上讲，Fuchsia *API level* 是一个无符号的 64 位整数 [^1]。
随着平台的发展（参见下面的*演进*），API 级别分配在
顺序递增，旨在为人类（包括最终开发人员）所理解。

#### ABI 修订

Fuchsia *ABI revision* 表示 [Fuchsia System Interface] 的语义
应用程序期望平台提供的信息。Fuchsia 的给定版本
通常支持多个 ABI 修订，但支持给定的语义
ABI 修订应该在 Fuchsia 中保持一致（参见下面的*Evolution*）
发布。

> *Example.* 考虑 `zx_clock_get_monotonic`，这是一个由
vDSO 作为 [Fuchsia System Interface] 的一部分。ABI 修订版指定
该函数是否存在以及调用该函数时会发生什么，
这意味着`zx_clock_get_monotonic`的语义应该是一致的
在同一个 ABI 版本中跨 Fuchsia 版本。

在语法上，Fuchsia *ABI revision* 是一个无符号的 64 位整数。一个 ABI
修订版是一个不透明的标识符，没有内部结构。创建一个
新 ABI 版本的标识符，随机选择一个无符号的 64 位整数
在从未用于识别 Fuchsia ABI 修订的值中
前。

ABI 修订的标识符是随机选择的，以防止最终开发人员
从猜测未来的 ABI 修订标识符和形成关于
[Fuchsia System Interface] 未来版本的语义。作为一个
结果，ABI 修订旨在被机器理解，并且很少被机器理解
被人类解读。

#### 进化

每当平台添加或删除一个
[Fuchsia IDK] 中的 API 或 ABI 修订版更改时。在实践中，
项目可能会通过在某些定义的节奏上增加 API 级别来批量更改
（例如，一天一次或一周一次）。

每当平台进行 ABI 修订时，平台都会更改
*向后不兼容*更改为
【Fuchsia系统界面】。在实践中，该项目可能会批量
通过更改某些已定义的 ABI 版本来进行向后不兼容的更改
节奏（例如，每六周或每六个月）。

在极限情况下，语义的每一次变化都可能向后不兼容，
但是，在实践中，操作系统确实会更改其语义，而无需
打破应用程序。例如，许多流行的操作系统添加系统
调用而不破坏他们的应用程序。

> *Action item.* 创建一个文档，详细说明 Fuchsia 的变化
平台认为是向后兼容的系统接口。该项目
随着项目的进展，可能需要随着时间的推移完善该文件
关于更改通常会做什么和不会中断的实施经验
实践中的应用。

### 应用程序

最终开发人员在构建组件时选择一个*目标 API 级别*。
目标 API 级别控制 [Fuchsia IDK] 中的哪些声明
在构建组件时可用。例如，FIDL 消息
API 级别 7 中引入的组件在构建组件时不可用
以 API 级别 6 为目标，但在构建以 API 为目标的组件时可用
级别 7 或 8（假设 API 级别 8 中未弃用该消息）。

作为构建组件的一部分，SDK 中的工具包括
*目标 ABI 修订版* 与清单中的目标 API 级别相关联
组件。这样，每个组件都声明了
开发人员希望平台在他们构建组件时提供。一个
给定的包可以包含许多组件，每个组件都可以选择任何一个
他们喜欢的目标 ABI 版本。

### 平台

该平台维护*支持的 ABI 修订*列表。该平台
为针对受支持 ABI 的组件提供二进制兼容性
修订，这意味着平台将尝试为这些组件提供
由其目标 ABI 修订版指示的平台语义。

> *Example.* 考虑从 `fuchsia.foo.Bar` 协议到
`fuchsia.foo.Bar2` 协议。假设一个组件“baz.cm”有一个目标 ABI
表示组件期望平台提供
`Fuchsia.foo.Bar`。运行 `baz.cm` 时，平台将路由请求
`fuchsia.foo.Bar` 到适当的实现。但是，运行时
转换后具有目标 ABI 修订的组件
`fuchsia.foo.Bar2`，平台将不再路由请求
`fuchsia.foo.Bar` 到一个实现，因为针对该 ABI 的组件
修订版应该改用 `fuchsia.foo.Bar2`。

在某些时候，平台可能希望删除对给定 ABI 的支持
修订。此类删除通常在重要组件的尾部进行限制，这些组件
仍然依赖旧的 ABI 修订版。而不是保持完整的语义
旧 ABI 修订暗示，该平台维护一个 *legacy 列表
components* 以及运行那些特定的 *quirks* 表
成分。quirk 是一种兼容性填充程序，它允许遗留组件使用
否则不支持的接口。使用这种机制，平台可以移除
对旧 ABI 版本的一般支持，同时仍然能够运行某些
针对旧 ABI 修订版的重要组件。

> *示例。*假设平台不再支持任何 ABI 修订
包括 `fuchsia.foo.Bar` 但 `baz.cm` 是一个重要的组件
未迁移到 `fuchsia.foo.Bar2`。该项目可以将 `baz.cm` 视为遗产
具有 `needs-fuchsia-foo-bar` 怪癖的组件。虽然平台有
不支持`baz.cm`的目标ABI版本，平台可以继续
通过将其对 `fuchsia.foo.Bar` 的请求路由到兼容性来运行 `baz.cm`
垫片，可能使用 `fuchsia.foo.Bar2` 实现。兼容性垫片确实
不需要支持 `fuchsia.foo.Bar` 所隐含的完整语义。反而，
兼容性垫片只需要工作得足够好以保持 `baz.cm`（和
其他具有 `needs-fuchsia-foo-bar` 怪癖的特定组件）工作。

平台无法运行既不针对支持的 ABI 修订版的组件
也没有被列为遗留组件，因为平台不知道什么
这些组件所期望的语义。

### 生命周期 {#lifecycle}

【Fuchsia系统界面】【Fuchsia系统界面】的每一个元素
（例如，系统调用或 FIDL 消息）经历以下生命周期：

1. 元素被*引入*到平台中。最终开发者不能使用
   API 直到 Fuchsia 发布具有新 API 级别的 SDK，其中包括
   元素。如果可以在不破坏 ABI 的情况下引入元素（例如，
   添加系统调用），则现有 ABI 修订的语义可以是
   更新以包括新引入的元素。否则，该元素必须
   对针对旧 ABI 修订的组件隐藏以避免破坏
   他们。
2. 如果可能，可以通过引入子元素来*扩展*元素。
   例如，可以通过引入新字段来扩展 FIDL 表。
   引入子元素会启动元素生命周期的另一个实例
   对于该子元素，包括需要新的 API 级别来创建 API
   对于最终开发人员可见的元素。一个元素只能扩展
   如果添加子元素不会破坏现有的 API 或 ABI。
3. 该元素可能*已弃用*。针对旧 ABI 的组件
   在较新的平台版本上运行时，修订版仍然可以使用该元素。
   但是，针对较新 API 的最终开发人员
   level 不能再使用该元素。
4. 一旦平台不再支持任何 ABI，该元素就是 *legacy*
   元素的 *introduction* 和 *deprecation* 之间的修订。在
   在这一点上，平台只需要支持元素，只要
   element 实际上是由一个特定的遗留组件通过一个怪癖来使用的。
5. 一旦没有遗留组件使用该元素，该元素可以
   *完全从平台上移除*。

### 动态{#dynamics}

这种方法激励开发人员从弃用的接口迁移
通过耦合对新 API 的访问来执行这些迁移。具体来说，对
获得对新引入的 API 的访问权限，开发人员必须更改他们的目标
API 级别，这要求他们迁移过去的任何接口
在该 API 级别中已弃用。

## 执行

实现此设计涉及 Fuchsia 系统的许多层。这个
文档提供了每个相关层所需更改的草图，但是
这些层的详细设计留给后续文件。

### FIDL {#fidl}

FIDL 应该提供一种方法来注释每个 API 级别的范围
协议元素可用。FIDL 工具链应该知道
目标 API 级别并生成适合该 API 级别的代码。

当一个协议元素（例如，表中的字段或协议中的消息）是
在给定的 API 级别已弃用，理想情况下，我们希望组件
该 API 级别能够接收包含该协议元素的消息
但想阻止那些组件发送包含
该协议元素。

### 系统头文件

系统标头应让最终开发人员指定目标 API 级别和
然后根据使用这些标头调整可见的 API 集
目标 API 级别。此外，系统头文件应定义宏
可用于限制其他库中声明的可见性
某些 API 级别。

### vDSO

系统应提供多个 vDSO，每个 vDSO 都支持 ABI 列表
修订。如果可能，系统应该通过扩展 vDSO 来演进
向后兼容的方式，但是，如果不可能，系统可以创建一个新的 vDSO
带有支持的 ABI 修订版的单独列表。

扩展 vDSO 会增加现有二进制文件的攻击面，因为
那些现有的二进制文件可以访问 vDSO 扩展。决定时
无论是扩展现有的 vDSO 还是创建新的 vDSO，项目
应考虑安全隐患以及兼容性
影响。

vDSO 可以提供一个功能来检查 vDSO 是否支持给定的
ABI 修订版，但 vDSO 不应直接公开支持的 ABI 列表
修订，因为将该列表公开给应用程序会使应用程序中断
当列表扩展时。

### 流程框架

当启动一个进程时，客户端应该通知进程启动器哪个
流程预期的 ABI 修订。进程启动器应该使用它
选择适当的 vDSO 和处理引导消息的信息
新启动的进程。

> *未解决的问题。* 创建流程时我们应该使用什么 ABI 修订版
没有组件清单？一种可能性是将 ABI 修订版放入
可执行文件的 ELF 数据，而不是组件中的（除了？）
显现。另一种可能性是将 ABI 修订添加到
`fuchsia.ldsvc.Loader` 协议，通常路由到
可执行。

### 组件框架

构建组件清单的工具应该将目标 API 级别作为
命令行参数并在组件中嵌入相应的 ABI 修订
他们创造的清单。

虽然不是立即需要，但组件最终会想要调制
根据 ABI 修订的能力路线。例如，一个组件可能希望
停止为其子组件之一提供某种服务。删除
立即服务可能会破坏与该孩子的旧版本的兼容性
零件。相反，父母可能只想为孩子提供服务
针对较旧的 ABI 修订版。

同样，该平台可能希望为特定的传统路由功能
组件到提供兼容性垫片的专用目的地。为了
例如，我们可以定义一个路由 *quirk* 应用于特定的 legacy
怪癖表中具有该怪癖的组件。

### SDK

SDK 应指定 SDK 支持的 API 级别和映射
在这些 API 级别和它们的 ABI 版本之间以某种机器可读的格式
（例如，在其 JSON 元数据中）。应修改 SDK 集成以允许
最终开发人员指定目标 API 级别并将目标 API 级别提供为
所有需要该值的工具的命令行参数。

## 表现

该提议试图最小化平台版本控制的性能影响
通过在构建和发现期间干预主节点。使用的兼容性垫片
运行遗留组件可能会对性能产生重大影响，但
项目可以根据具体情况评估这些绩效影响
将组件添加到遗留组件列表时。

## 安全注意事项 {#security-considerations}

该提案应该对安全性产生积极影响，因为该提案
将使 Fuchsia 软件生态系统更容易迁移到更新的 API，
它可能比旧的 API 具有更好的安全属性。

此外，分配新 ABI 修订的能力使
避免将新的 ABI 暴露给现有的应用程序，这可以减少攻击
暴露于这些应用程序的表面。在决定是否延长
现有的 ABI 或是否分配新的 ABI 修订，项目应
考虑分配新 ABI 修订版的安全优势。

该提案确实为恶意应用程序提供了一种选择机制
平台中不同的、可能较旧的代码路径，例如通过声明
以较旧的 ABI 修订为目标。随着平台的发展，项目将需要
以相同的安全努力处理支持旧 ABI 修订的代码
该项目处理支持较新 ABI 修订的代码。

## 隐私注意事项

该提案应该对隐私产生积极影响，因为该提案
将使 Fuchsia 软件生态系统更容易迁移到更新的 API，
它可能比旧的 API 具有更好的隐私属性。

## 测试

该提议在一定程度上增加了测试矩阵，因为平台的行为
取决于正在运行的组件的 ABI 版本。我们会需要
将测试矩阵的这种增加纳入 Fuchsia 的设计中
兼容性测试套件 (CTS)。例如，项目可能想要版本
CTS根据ABI改版保证平台不退步
随着它的发展，它对旧 ABI 修订版的支持。

## 文档

应该更新平台的文档以注释每个 API
它在生命周期中的当前阶段以及它的生命周期历史（例如，当
API 被引入、弃用和/或删除）。这些注释应该是
源自控制应用程序是否具有相同的事实来源
以特定 API 级别为目标时访问这些 API。例如，
`fidldoc` 工具应该了解 FIDL 源代码中的 API 级别注释
文件并在生成的文档中生成适当的注释。

每当平台创建新的 ABI 修订标识符时，项目应该
更新文档以描述新的 ABI 修订在哪些方面不是
向后兼容以前的 ABI 修订版以及采取什么措施（如果有），
最终开发人员在更新他们的应用程序时应该采取。

此外，该项目应该有一些概念文档来解释
为什么平台有 API 级别以及如何从一个 API 级别升级到
其他。

## 缺点、替代方案和未知数

### 实施此提案的成本是多少？

实施该提议的主要成本是增加了运营复杂性
在发展平台时。添加新的 API 现在需要协调
以新的 API 级别发布该 API 的项目。同样，弃用
ABI 涉及更多，因为弃用发生在几个步骤中。

系统本身也将变得更加复杂，因为
系统将部分依赖于每个组件的 ABI 版本。

### 还有什么其他策略可以解决同样的问题？

其他一些平台使用的另一种策略是永远不要删除
功能。例如，网络平台几乎完全是累加的。
在某些方面，这种方法更简单，因为系统不需要
弃用功能的机制。

另一种方法可能是对不同的版本使用不同的版本标识符
系统的一部分，而不是适用于整个系统的单个 API 级别
系统。在一定程度上，Fuchsia 也使用了这种方法。例如，
每个文件系统都有自己的版本标识符，用于
磁盘上的表示和文件的内存代码之间的契约
系统。对整个系统使用单个 API 级别意味着在一定程度上
平台与平台之间合约演化的协调
应用程序。

## 现有技术和参考文献 {#prior-art-and-references}

关于这个主题有大量的现有技术。在这个提议
文档直接建立在 Android、Windows 和 macOS/iOS 的经验之上。

### 安卓

Android 有 API 级别的概念。Android 上的每个平台界面都是
使用引入接口的 API 级别进行注释。安卓
应用程序还使用
[`uses-sdk`] 元素。原则上，Android 可以使用这种 API 级机制
弃用和删除旧接口。

### 窗户

Windows 大量使用了一个类似于 ABI 修订的概念，它显示为
应用程序清单中的 [`SupportedOS`] 条目。Windows 使用 GUID
识别应用程序所针对的 ABI 修订版，类似
对本文档中的建议使用不透明的 64 位整数。

在 Windows 中，`SupportedOS` GUID 与特定版本的
视窗。例如，`e2011457-1546-43c5-a5fe-008deee3d3f0` 标识 Windows
远景。但是，更高版本的 Windows（例如，Windows 7）理解
`e2011457-1546-43c5-a5fe-008deee3d3f0` GUID 并提供与
Windows Vista ABI。本文档中的提议将 ABI 修订与
平台发布，更加灵活。

### macOS，iOS

macOS 和 iOS 都使用 [`API_AVAILABLE`] 和 `@available` 注解
控制在构建应用程序时声明是否可用。
系统库（又名框架）也使用“链接在或之后”检查和
显式 quirk 表以支持需要较旧应用程序的旧应用程序
来自平台的语义。

Apple 已成功使用这些机制为这些应用程序迁移
操作系统从较旧的 API 到较新的 API。

[^1]: [RFC-0083: FIDL Versioning][rfc-0083] amends this, restricting
    API levels to 63 bits in order to reserve the high bit for other uses.

[Fuchsia系统接口]: concepts/packages/system.md
[Fuchsia IDK]: development/idk/README.md
[`uses-sdk`]: https://developer.android.com/guide/topics/manifest/uses-sdk-element
[`SupportedOS`]: https://docs.microsoft.com/en-us/windows/win32/win7appqual/compatibility---application-manifest#leveraging-feature-capabilities
[`API_AVAILABLE`]: https://developer.apple.com/documentation/swift/objective-c_and_c_code_customization/marking_api_availability_in_objective-c
[rfc-0083]: contribute/governance/rfcs/0083_fidl_versioning.md
