<!-- # Developing with Fuchsia packages

Almost everything that exists on a Fuchsia system is a [Fuchsia package][pkg-struct].
Whether it is immediately apparent or not almost everything you see on
Fuchsia lives in a package. This document will cover the basics of a
package-driven workflow where you [build][pkg-doc] a package and push it to a
Fuchsia device that is reachable via IP from your development host. -->

# 开发 Fuchsia 包

几乎所有在 Fuchsia 系统中存在的东西都是一个 [Fuchsia 包][pkg-struct]。不论是否显而易见，Fuchsia 中任何东西都是在以包的形式存在。这份文档将涵盖包驱动的工作流的基础知识，在该工作流中您将 [构建][pkg-doc] 包，并将其推送到任何一个能通过 IP 访问到您的开发主机的 Fuchsia 设备。

<!-- ## Pre-requisites and overview

The host and target must be able to communicate over IP. In particular
it must be possible to SSH from the development host to the target device, and
the target device must be able to connect via TCP to the development host on
port 8083. The SSH connection is used to issue commands to the target device. -->

## 必备条件以及概述

开发主机与目标设备必须能通过 IP 互相访问。特别的，必须能够通过 SSH 从开发主机连接到目标设备，而且目标设备必须能够通过 TCP 连接到开发主机的 8083 端口。SSH 连接用于向目标设备下发命令。

<!-- The development host will run a simple, static file, HTTP server that makes the
updates available to the target. This HTTP server is part of the Fuchsia source
code and built automatically. -->

开发主机会运行一个简单的静态文件，HTTP 服务器会使该更新对目标设备可用。这个 HTTP 服务器使 Fuchsia 源码的一部分，会自动构建。

<!-- The target is instructed to look for changes on the development host via a
couple of commands that are run manually. When the update system on the target
sees these changes it will fetch the new software from the HTTP server running
on the host. The new software will be available until the target is rebooted. -->

目标设备会通过手动运行一些指令来查找开发主机上的更改。当目标设备上的更新系统发觉了这些改变就会从开发主机上运行着的 HTTP 服务器获取新的软件。新软件将一直可用，直到目标设备重新启动。

<!-- ## Building -->

## 构建

<!-- TODO(jmatt): improve to talk about wider variety of build options -->

<!-- To build a package containing the required code, a package type build rule is
used. If one of these needs to be created for the target package, consult the
reference [page][pkg-doc] for this. Some build rule types are actually
extensions of the package rule type, for example [`flutter_app`][flutter-gni]
extends the package type. -->

为了构建一个包含所需代码的包，需要使用包类型构建规则。如果需要为目标包创建一个规则，请查阅 [这份文档][pkg-doc]。某些构建规则类型实际上只是包规则类型的扩展，例如，[`flutter_app`][flutter-gni] 扩展了包规则。

<!-- Once an appropriate build rule is available the target package can be
re-generated by running `fx build`. -->

一旦有可用的恰当的构建规则，目标包就能通过运行 `fx build` 命令来重新生成。

## Connecting host and target

The Fuchsia source contains a simple HTTP server that serves static files. The
build generates and serves a [TUF][TUF-home] file tree.

## 连接主机与目标设备

<!-- The update agent on the target does not initially know where to look for
updates. To connect the agent on the target to the HTTP server running on the
development host, it must be told the IP address of the development host. -->

目标设备上的更新管理器最初并不知道要去哪里查找更新。为了连接目标设备与开发主机上的 HTTP 服务器就必须将开发主机的 IP 地址告知目标设备上的更新管理器。

<!-- The host HTTP server is started and the update agent is configured by calling
`fx serve -v` or `fx serve-updates -v`.  `fx serve` will run both the bootserver
and the update server and is often what people use. `fx serve-updates` runs just
the update server. In both cases, `-v` is recommended because the command will
print more output, which may assist with debugging.  -->

当主机上的 HTTP 服务器启动之后，更新管理器会通过调用 `fx serve -v` 和 `fx serve-updates -v` 命令得到配置。常用的命令 `fx serve` 会同时运行引导服务器和更新服务器。在两种情况下，`-v` 参数会让命令打印出更多的信息，以便于调试。

<!-- If the host connects
successfully to the target you will see the message `Ready to push packages!` in
the shell on your host. -->

如果主机成功与目标设备相连，主机的终端中会出现 `准备推送包！` 这样的信息。

<!-- The update agent on the target will remain configured until it is repaved or
persistent data is lost. The host will attempt to reconfigure the update agent
when the target is rebooted. -->

目标设备上的更新管理器会保持之前的配置，知道设备被重新铺设或保存的数据丢失。在目标设备重启之后，主机将会尝试重新配置其更新管理器。

<!-- ## Triggering package updates

Packages in Fuchsia are not "installed", they are cached on an as needed
basis. There are two collections of packages on a Fuchsia system: -->

## 启动包更新

Fuchsia 中的包并非是被「安装」的，它们是按需被缓存的。Fuchsia 中的包主要有两种：

<!-- * **base** The base package set is a group of software critical to proper
  system function that must remain congruent. This set of software can only be
  updated by performing a whole system update, typically referred to as OTA,
  described below. This is updated using `fx ota`. -->

* **基本包** 基本包是一组对正确的系统功能至关重要的软件，必须保持一致。基本包只能通过完全的系统更新获得更新，通常被称为 OTA，后续将对其进行描述。这是使用 `fx ota` 进行更新的。

<!-- * **ephemeral software** The ephemeral software is provided to the system in
  one of two ways, either as a member of the "cache" build group, or entirely
  ephemerally. Typically users configure software in the Fuchsia build as
  ephemerally available by adding that package to the `fx set` line such as
  `--with //examples/rolldice`. Ephemeral software, whether in "cache" or
  entirely ephemeral, is always updated whenever a component is launched with a
  package URL. For example, if a user executes `fx run
  fuchsia-pkg://fuchsia.com/rolldice#meta/rolldice.cmx`, the rolldice latest
  rolldice package will be cached before execution. -->

* **临时包** 临时包会通过以下两种方式的其中之一来提供给系统，一种是「缓存」构建组，另一种是完全临时。通常用户会通过 `fx set` 命令并设置诸如 `--with //examples/rolldice` 这样的参数在构建中将该包配置为临时可用。无论是「缓存」还是完全临时的临时包，都只会在一个组件通过包 URL 加载时才会获得更新。例如，如果一个用户运行 `fx run
  fuchsia-pkg://fuchsia.com/rolldice#meta/rolldice.cmx`，rolldice 的最新包会在执行前被缓存。

<!-- ## Triggering an OTA

Sometimes there may be many packages changed or the kernel may change or there
may be changes in the system package. To get kernel changes or changes in the
system package an OTA or [pave][paver] is *required* as **base** packages are
immutable for the runtime of a system. An OTA update will usually be faster
than paving or flashing the device. -->

## 启动一次 OTA

有时会有很多包改变或内核改变或者系统包发生改变。由于系统运行期间 **基本包** 无法被改变，因此需要通过 OTA 或 [铺设][paver] 来获取内核更新或系统包更新。OTA 更新通常要比铺设或刷写设备要快。

<!-- The command `fx ota` asks the target device to perform an update from any of
the update sources available to it. To OTA update a build made on the dev host to
a  target on the same LAN, first build the system you want. If `fx serve [-v]`
isn't already running, start it so the target can use the development host as an
update source. The `-v` option will show more information about the files the
target is requesting from the host. If the `-v` flag was used there should
be a flurry of output as the target retrieves all the new files. Following
completion of the OTA the device will reboot. -->

`fx ota` 会要求目标设备从任意可用更新源执行更新。若要通过 OTA 将在开发主机上进行的构建更新到同一局域网上的目标设备，首先需要构建你所需的系统。如果 `fx serve [-v]` 还没有运行，那么先运行该命令使目标设备将开发主机作为更新源。`-v` 选项会展示更多关于目标设备所请求的主机文件的信息。如果 `-v` 选项被打开，在目标设备获取所有新文件时，都会有一系列输出。OTA 结束之后，设备将会重启。


<!-- ## Just the commands

  * `fx serve -v` (to run the update server for both build-push and ota)
    * `fx serve-updates -v` (to run only the update server, not the bootserver)
  * `fx run <component-url>` (each time a change is made you want to run)
  * `fx test <component-url>` (to build and run tests)
  * `fx ota` (to trigger a full system update and reboot) -->

## 仅需这些命令

* `fx serve -v` （为构建-推送和 OTA 启动更新服务器）
  * `fx serve-updates -v` （只启动更新服务器而不启动引导服务器）
* `fx run <component-url>` （每次做出更改时，当你想要运行它时）
* `fx test <component-url>` （构建并运行测试）
* `fx ota` （触发一次完整系统升级并重启设备）

<!-- ## Issues and considerations

### You can fill up your disk

Every update pushed is stored in the content-addressed file system, blobfs.
Following a reboot the updated packages may not be available because the index
that locates them in blobfs is only held in RAM. The system currently does not
garbage collect inaccessible or no-longer-used packages (having garbage to
collect is a recent innovation!), but will eventually. -->

## 问题与注意事项

### 你的硬盘可能会被装满

每次更新的推送都保存在内容寻址的文件系统，blobfs 中。重启之后，更新包可能不再可用，因为它们在 blobfs 中的索引只保存在内存中。Fuchsia 系统目前不收集不可访问或不再使用的包（垃圾收集是最近才提出来的），但我们最终一定会有垃圾回收！

<!-- The command `fx gc` will reboot the target device and then evict all old
ephemeral software from the device, freeing up space. -->

`fx gc` 命令会重启目标设备并删除所有旧临时软件包来回收空间。

<!-- ### Restarting without rebooting

If the package being updated hosts a service managed by Fuchsia that service
may need to be restarted. Rebooting is undesirable both because it is slow and
because the package will revert to the version paved on the device. Typically
a user can terminate one or more running components on the system, either by
asking the component to terminate gracefully, or by forceufully stopping the
component using `fx shell killall <component-name>`. Upon reconnection to the
component services, or by invocation via `fx run` or `fx test`, new versions
available in the package server will be cached before launch. -->

### 不重启设备的情况下重启服务

如果正被更新的包含有由 Fuchsia 管理的服务，那么该服务可能需要重启。重启是不可取的，因为很慢而且更新的那个包会被恢复到更新前的版本。通常，用户可以终止一个或多个系统中正在运行的组件，既可以要求组件正常终止，也可以通过 `fx shell killall <component-name>` 命令来强制终止一个组件。一旦重新连接到组件服务，或通过 `fx run` 或 `fx test` 调用，包服务器中可用的新版本将在启动前缓存。

<!-- ### Packaging code outside the Fuchsia tree

Packaging and pushing code that lives outside the Fuchsia tree is possible, but
will require more work. The Fuchsia package format is quite simple. It consists
of a metadata file describing the package contents, which is described in more
detail in the [Fuchsia package][pkg-struct] documentation. The metadata file is
added to a TUF file tree and each of the contents are named after their Merkle
root hash and put in a directory at the root of the TUF file tree called 'blobs'. -->

### 在 Fuchsia 环境外打包代码

在 Fuchsia 环境外打包并发布代码是可能的，但是需要做更多的工作。Fuchsia 包结构非常简单。它含有一个描述包内容的元数据文件，在 [Fuchsia 包][pkg-struct] 文档中描述了它的更多细节。元数据文件被添加到 TUF 文件树中，每个内容都以它们的墨克根哈希命名，并放在 TUF 文件树的根的一个目录里，并称之为 「blobs」。

[pkg-struct]: /src/sys/pkg/bin/pm/README.md#structure-of-a-fuchsia-package "Package structure"
[TUF-home]: https://theupdateframework.github.io "TUF Homepage"
[pkg-doc]: /docs/concepts/build_system/fuchsia_build_system_overview.md "Build overview"
[flutter-gni]: https://fuchsia.googlesource.com/topaz/+/HEAD/runtime/flutter_runner/flutter_app.gni "Flutter GN build template"
[paver]: /docs/development/hardware/paving.md "Fuchsia paver"
[OTA]: #triggering-an-ota "Triggering an OTA"
